<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ This is part of Geomajas, a GIS framework, http://www.geomajas.org/.
  ~
  ~ Copyright 2008-2015 Geosparc nv, http://www.geosparc.com/, Belgium.
  ~
  ~ The program is available in open source according to the GNU Affero
  ~ General Public License. All contributions in this program are covered
  ~ by the Geomajas Contributors License Agreement. For full licensing
  ~ details, see LICENSE.txt in the project root.
  -->
<!DOCTYPE part PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<part id="part-howto">
  <title>How-to</title>

  <chapter id="ch-howto-command">
    <title>Writing your own commands</title>

    <para>A Geomajas command usually consist of three classes, the actual
    command (which implements the <code>Command</code> interface), and two
    data transfer objects, one to pass the request parameters (extending
    <code>CommandRequest</code>, <code>LayerIdCommandRequest</code> or
    <code>LayerIdsCommandRequest</code>), and one which carries the response
    (extending <code>CommandResponse</code>).</para>

    <para>It is important to assure your request object extends from
    LayerIdCommandRequest or LayerIdsRequest when one of the parameters is the
    layer id (or a list thereof). This can be used by the command dispatcher
    to assure the layer specific (transaction) interceptors are called.</para>

    <para>To create a new command we recommend you use a similar package
    structure as we used in the geomajas-extension-command module. That is to
    create a "command" package with under that a "dto" package which contains
    all the request and response objects, and to put the actual commands in
    sub packages based on some kind of grouping. This helps to automatically
    determine a sensible command name.</para>

    <para>The basic command implementation looks like this:</para>

    <xi:include href="listing/ExampleCommand.xml"
                xmlns:xi="http://www.w3.org/2001/XInclude" />

    <para>Note the presence of the "@Component" annotation which assures the
    command is registered. You could add the name under which the command
    needs to be registered in the annotation, but when that is omitted, the
    default command name is derived from the fully qualified class name. In
    the example given here this results in command name
    "command.mysuper.DoIt".</para>

    <para>The default way to determine the command name assumes there is a
    package named "command" in the fully qualified name of the implementing
    class. It will remove everything before that. It will then remove a
    "Command" suffix if any. Lastly, it will remove duplication between the
    intermediate package (between "command" and the class name) and the class
    name itself. Some examples:</para>

    <para>
      <table>
        <title>Samples of command name resolution</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Fully qualified class name</entry>

              <entry>Command name</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>my.app.command.DoIt</entry>

              <entry>command.DoIt</entry>
            </row>

            <row>
              <entry>my.app.command.super.DoIt</entry>

              <entry>command.super.DoIt</entry>
            </row>

            <row>
              <entry>my.app.command.super.DoItCommand</entry>

              <entry>command.super.DoIt</entry>
            </row>

            <row>
              <entry>my.app.command.super.SuperDoItCommand</entry>

              <entry>command.super.DoIt</entry>
            </row>

            <row>
              <entry>my.app.command.super.DoItSuperCommand</entry>

              <entry>command.super.DoIt</entry>
            </row>

            <row>
              <entry>my.app.command.super.CommandDoIt</entry>

              <entry>command.super.CommandDoIt</entry>
            </row>

            <row>
              <entry>my.app.command.super.CommandSuperDoIt</entry>

              <entry>command.super.CommandSuperDoIt</entry>
            </row>

            <row>
              <entry>my.app.command.super.CommandDoItSuper</entry>

              <entry>command.super.CommandDoIt</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </para>

    <para>You have to include a line in your Spring configuration to scan
    class files for annotation to make the components available. For the case
    above, this could be done by including the following XML fragment in one
    of your Spring configuration files.</para>

	  <example id="ExampleCommandScan">
		  <title>Scan to assure command is available</title>
		  <programlisting language="xml"><![CDATA[<context:component-scan base-package="com.my.program" name-generator="org.geomajas.spring.GeomajasBeanNameGenerator" />]]>
		  </programlisting>
	  </example>


	  <para>The command will be executed using a singleton. The use of object
    variables is not recommended. Any object variables will be shared amongst
    all command invocation, which can be coming from multiple threads at the
    same time.</para>

    <para>Note that it is not mandatory to create your own request and
    response object classes. If you don't require any parameters you can use
    <code>EmptyCommandRequest</code> as request class. If you only require a
    layer id, then use <code>LayerIdCommandRequest</code>. If you only return
    a success code, you could use the <code>SuccessCommandResponse</code>
    class.</para>

    <para>You have to take care that all objects which are referenced by your
    request and response objects are actually serializable for the faces in
    which the commands need to be used. For the dojo face this may require the
    use of the "<code>@Json</code>" annotation to exclude fields. For GWT you
    have to assure the no-arguments constructor exists and that the class can
    be compiled by GWT (no Hibernate enhanced classes, no use of
    "<code>super.clone()</code>",...).</para>

    <para>When the commands are included in a separate module, you should
    assure the sources are available as these are needed for GWT compilation.
    This can easily be done using the Maven source plug-in.</para>

	  <!--In stead of include, copy example code from a pom.xml -->
    <!--<xi:include href="listing/MavenSourcePlugin.xml"-->
                <!--xmlns:xi="http://www.w3.org/2001/XInclude" />-->
	  <example id="MavenSourcePlugin">
		  <title>Maven source plugin</title>
		  <programlisting language="java"><![CDATA[<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-source-plugin</artifactId>
    <version>2.1.2</version>
    <executions>
        <execution>
            <goals>
                <goal>jar</goal>
            </goals>
            <configuration>
                <includePom>true</includePom>
            </configuration>
        </execution>
    </executions>
</plugin>]]>
		  </programlisting>
	  </example>

    <para>Actually including the sources can then be done using a dependency
    like the following (this includes the staticsecurity module, both the
    actual code and the sources). You could set "provided" scope on the source
    dependency to exclude it from the war file. However, this may prevent use
    of GWT development mode.</para>

	  <!--In stead of include, copy example code from a pom.xml -->
    <!--<xi:include href="listing/StaticSecurityDependency.xml"-->
                <!--xmlns:xi="http://www.w3.org/2001/XInclude" />-->
	  <example id="StaticSecurityDependency">
		  <title>staticsecurity source plugin - including source</title>
		  <programlisting language="java"><![CDATA[<dependency>
    <groupId>org.geomajas.plugin</groupId>
    <artifactId>geomajas-plugin-staticsecurity</artifactId>
    <version>${geomajas-plugin-staticsecurity-version}</version>
</dependency>
<dependency>
    <groupId>org.geomajas.plugin</groupId>
    <artifactId>geomajas-plugin-staticsecurity</artifactId>
    <version>${geomajas-plugin-staticsecurity-version}</version>
    <classifier>sources</classifier>
</dependency>
<dependency>
    <groupId>org.geomajas.plugin</groupId>
    <artifactId>geomajas-plugin-staticsecurity-gwt</artifactId>
    <version>${geomajas-plugin-staticsecurity-version}</version>
</dependency>
<dependency>
    <groupId>org.geomajas.plugin</groupId>
    <artifactId>geomajas-plugin-staticsecurity-gwt</artifactId>
    <version>${geomajas-plugin-staticsecurity-version}</version>
    <classifier>sources</classifier>
</dependency>]]>
		  </programlisting>
	  </example>
    <para />
  </chapter>

  <chapter id="ch-howto-plugin">
    <title>Create a plug-in</title>

    <para>The general procedure for creating a new plug-in is described here.
    Additional information for specific types of plug-ins is described in
    subsequent chapters.</para>

    <section id="pi-arch">
      <title>Using the plug-in archetype</title>

      <para>You can easily create the skeleton of a plug-in using the Geomajas
      plug-in archetype Archetype.</para>

      <orderedlist>
        <listitem>
          <para><emphasis>Step1</emphasis>: Go to the folder where you want to
          create the plug-in, and execute the following command:</para>

          <example>
            <title>Create project using GWT Maven archetype</title>

            <programlisting>mvn archetype:generate -DarchetypeCatalog=http://files.geomajas.org/archetype-catalog.xml</programlisting>
          </example>

          <para>This will create the template project, using the latest stable
          release. If you want to use the latest snapshot, use the following
          command instead:</para>

          <example>
            <title>Create project using GWT Maven archetype</title>

            <programlisting>mvn archetype:generate -DarchetypeCatalog=http://files.geomajas.org/archetype-latest.xml</programlisting>
          </example>

          <para>Maven will now prompt the user for input.</para>

          <note>
            <para>If anything fails with these maven commands, you need to
            check the output to check the problem. One typical problem is the
            need to define a proxy to allow maven to access sites in the
            outside world. See the <ulink
            url="http://maven.apache.org/guides/mini/guide-proxies.html">http://maven.apache.org/guides/mini/guide-proxies.html</ulink>
            for details.</para>
          </note>
        </listitem>

        <listitem>
          <para><emphasis>Step2</emphasis>: Maven will display the full list
          of available archetypes. Make sure you select the correct one:
          <emphasis role="bold">geomajas-plugin-archetype</emphasis>. When
          using the archetypeCatalog mentioned above, this should be number 2.
          When getting the archetype from central (and your maven uses the
          latest maven-archetype-plugin) you can enter geomajas to filter the
          list of archetypes.</para>
        </listitem>

        <listitem>
          <para><emphasis>Step3</emphasis>: Next maven asks for the <emphasis
          role="bold">groupId</emphasis>. Often the package name is used. For
          a generic plug-in which is included in trunk this should be
          "org.geomajas.plugin", for a layer "org.geomajas.layer", for a
          widget plug-in "org.geomajas.widget" but for a face "org.geomajas"
          (this is not consistent because of historic reasons).</para>
        </listitem>

        <listitem>
          <para><emphasis>Step4</emphasis>: Next maven asks for the <emphasis
          role="bold">artifactId</emphasis>. This represents the simple name
          of your plug-in. In the example below this is "common-gwt". Note
          that a prefix will be added to the artifactId by the archetype. This
          is controlled later.</para>
        </listitem>

        <listitem>
          <para><emphasis>Step5</emphasis>: Next maven asks for the first
          version for your application. This needs to be changed to
          "1.0.0-SNAPSHOT" to comply with the versioning normally used in
          Geomajas.</para>
        </listitem>

        <listitem>
          <para><emphasis>Step6</emphasis>: Next maven asks for the base
          package wherein to place Java files. By default this is the same as
          the groupId. For plug-ins included in the project this should be
          groupId.artifactId.</para>
        </listitem>

        <listitem>
          <para>Step7: Maven asks you to confirm the parameters. Revise these
          and approve if everything is correct. Note that it also displayed
          the value for artifactIdPrefix. Indicate no when this should not be
          "geomajas-plugin-" (similar rules as above, it should be either
          "geomajas-plugin-" or "geomajas-face-" or "geomajas-widget-" or
          geomajas-layer-" for inclusion in the Geomajas project itself, note
          the ending dash).</para>
        </listitem>

        <listitem>
          <para>The project is now created.</para>
        </listitem>
      </orderedlist>

      <tip>
        <para>You have now create a Geomajas template project! It is best to
        continue by testing if everything went well.</para>
      </tip>

      <para>Example of full output for building a plug-in. In this case, some
      dummy data was first entered as the artifactIdPrefix needed to be
      changed.</para>

      <programlisting>joachim@joachim-E6320:~/temp$ mvn archetype:generate -DarchetypeCatalog=local
[INFO] Scanning for projects...
[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building Maven Stub Project (No POM) 1
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] &gt;&gt;&gt; maven-archetype-plugin:2.0:generate (default-cli) @ standalone-pom &gt;&gt;&gt;
[INFO] 
[INFO] &lt;&lt;&lt; maven-archetype-plugin:2.0:generate (default-cli) @ standalone-pom &lt;&lt;&lt;
[INFO] 
[INFO] --- maven-archetype-plugin:2.0:generate (default-cli) @ standalone-pom ---
[INFO] Generating project in Interactive mode
[INFO] No archetype defined. Using maven-archetype-quickstart (org.apache.maven.archetypes:maven-archetype-quickstart:1.0)
Choose archetype:
1: local -&gt; geomajas-gwt-archetype (Geomajas GWT application archetype)
2: local -&gt; geomajas-plugin-archetype (Geomajas plugin archetype)
Choose a number: : 2
Define value for property 'groupId': : gid
Define value for property 'artifactId': : aid
Define value for property 'version':  1.0-SNAPSHOT: : 
Define value for property 'package':  gid: : 
[INFO] Using property: artifactIdPrefix = geomajas-plugin-
Confirm properties configuration:
groupId: gid
artifactId: aid
version: 1.0-SNAPSHOT
package: gid
artifactIdPrefix: geomajas-plugin-
 Y: : n
Define value for property 'groupId': : org.geomajas
Define value for property 'artifactId': : common-gwt
Define value for property 'version':  1.0-SNAPSHOT: : 1.0.0-SNAPSHOT
Define value for property 'package':  org.geomajas: : org.geomajas.gwt
Define value for property 'artifactIdPrefix':  geomajas-plugin-: : geomajas-face
Confirm properties configuration:
groupId: org.geomajas
artifactId: common-gwt
version: 1.0.0-SNAPSHOT
package: org.geomajas.gwt
artifactIdPrefix: geomajas-face-
 Y: : 
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 50.040s
[INFO] Finished at: Thu Sep 15 13:29:46 CEST 2011
[INFO] Final Memory: 7M/118M
[INFO] ------------------------------------------------------------------------</programlisting>
    </section>

    <section id="pi-struct">
      <title>Plug-in structure</title>

      <para>The created plug-in contains a documentation module, a core module
      and a module for the GWT face. You can remove the "-gwt" module if that
      does not make sense for your plug-in.</para>
    </section>

    <section id="pi-depdec">
      <title>Plug-in declaration and dependencies</title>

      <para>As a reminder all dependencies should always be included in the
      dependencyManagement section in the parent pom for your project (that is
      -all module). You should also declare all the modules from the plug-in
      itself there. This was the version information is maintained in one
      place only. The child modules should not specify any versions (with the
      possible exception of -example modules).</para>

      <para>Note that the geomajas-dep dependency should only be used in
      -example modules.</para>

      <para>Please be careful about setting scopes in the dependencyManagement
      section. The -all module is normally used to fix the relevant version of
      plug-ins. Setting the scope in the -all module will trickle through and
      may overwrite the scope from another dependency (this may notable be a
      problem for test dependencies).</para>
    </section>
  </chapter>

  <chapter id="ch-howto-layer">
    <title>Create a layer plug-in</title>

    <para>Layers allow access to data which needs to be displayed in a
    map.</para>

    <para>For the existing layers, the details about configuring you map to
    include that layer are included in the <link
    linkend="backend-ch-configuration">section <xref
    linkend="backend-ch-configuration" /></link>.</para>

    <section id="writlay">
      <title>Writing your own layer</title>

      <para>TODO.....</para>
    </section>
  </chapter>

  <chapter id="ch-howto-security-plugin">
    <title>Create a security plug-in</title>

    <section id="writsecs">
      <title>Writing your own security service</title>

      <para>A security plug-in provides an implementation of the
      <code>org.geomajas.security.SecurityService</code> interface. The work
      is done in the <code>getAuthentication</code> method which returns an
      <code>Authentication</code> object for a token string. The back-end does
      not (need to) know how tokens are generated. This is the responsibility
      of the client. In the case of the GWT face, this is done using the
      <code>setTokenRequestHandler</code> method on
      <code>GwtCommandDispatcher</code>.</para>

      <para>The task of the security service is to read the policies and
      convert these into an <code>Authorization</code> objects. These contain
      methods to test whether certain operations are allowed or not. The
      different <code>Authorization</code> objects are combined by the
      <code>SecurityManager</code> into the <code>SecurityContext</code>,
      which can be injected in the code.</para>

      <para>The security service which is provided by the plug-in can then be
      used in the security configuration (see <link
      linkend="ch-secConf">chapter <xref
      linkend="ch-secConf" /></link>).</para>

      <para>For the implementation of your Authorization class, it is
      important to assure that the instances are serializeable and can also be
      deserialized. This is important to allow the caching to be clustered.
      While we don't require that the class implements
      <code>Serializeable</code> (thanks to the use of JBoss Serialization),
      you should think of the following points;</para>

      <itemizedlist>
        <listitem>
          <para>A no-arguments constructor is needed. This is allowed to be
          private (though that is not recommended, better make it protected if
          you don't want it to be generally used).</para>
        </listitem>

        <listitem>
          <para>If the authorization class is an inner class, do make it
          static if possible (otherwise the object has an implicit reference
          to the containing object, assuring it is included in the serialized
          state). The inner class should not be private as this cannot be
          deserialized.</para>
        </listitem>

        <listitem>
          <para>If you need a logger, declare it as<programlisting>private final transient Logger log = LoggerFactory.getLogger(ClassName.class);</programlisting>to
          ensure that the logger is not serialized.</para>
        </listitem>

        <listitem>
          <para>You should not use auto-wiring. Instead, make sure your class
          implements <code>AuthorizationNeedsWiring</code>. This defined the
          <code>wire()</code> method which allows you to query the application
          context. Make sure you declare wired properties as transient. The
          <code>wire()</code> method is called when the authorization is
          attached to the <code>SecurityContext</code> (both for freshly
          created and deserialized instances).</para>
        </listitem>
      </itemizedlist>
    </section>
  </chapter>

  <chapter>
    <title>Adding your own GWT service as a MVC controller</title>

    <para>When integrating Geomajas with an existing GWT application, you can
    add your existing GWT-RPC service to the application context as an MVC
    controller.</para>

    <section>
      <title>Create the MVC controller</title>

      <para>The code for creating an MVC controller can be based on the
      <code>GeomajasController</code> class (see <ulink
      url="http://grepcode.com/file/repo1.maven.org$maven2@org.geomajas$geomajas-face-common-gwt@1.1.0@org$geomajas$gwt$server$mvc$GeomajasController.java">GeomajasController.java</ulink>).
      Start by implementing your service (e.g. <code>MyService</code>) as a
      bean and autowiring it in a new controller:<programlisting>@Controller("/myService")
@Api
public class MyController extends RemoteServiceServlet implements MyService, ServletConfigAware {

  private static final long serialVersionUID = 100L;

  @Autowired
  private MyService myService;

  @Autowired(required = false)
  private ServletContext servletContext;
  
  private SerializationPolicyLocator serializationPolicyLocator;

  @RequestMapping("/myService")
  public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
    doPost(request, response);
    return null;
  }

  // put delegation methods here
  void myMethod() {
    myService.myMethod();
  }

  ....

  public ServletContext getServletContext() {
    if (null == servletContext) {
      throw new IllegalStateException("getServletContext() cannot be used outside web context");
    }
    return servletContext;
  }

  public void setServletConfig(ServletConfig servletConfig) {
    try {
      super.init(servletConfig);
    } catch (ServletException e) {
      throw new IllegalStateException("init(servletConfig) failed", e);
    }
  }
}</programlisting></para>

      <para>Use the url path of your choice in both the controller name and
      the request mapping value.</para>
    </section>

    <section>
      <title>Add the controller to the web context</title>

      <para>To add a controller to the web context, create a controller
      configuration file <code>mycontroller.xml</code> with the following
      content:<programlisting>&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
  xmlns:util="http://www.springframework.org/schema/util"
  xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context-3.0.xsd
        http://www.springframework.org/schema/util
    http://www.springframework.org/schema/util/spring-util-2.0.xsd"&gt;
  
  &lt;context:component-scan base-package="&lt;path.to.you.controller.package&gt;" /&gt;

&lt;/beans&gt;</programlisting>Use the correct scanning package here. This
      file can be put in WEB-INF and added to the config locations of the
      dispatcher servlet in your <code>web.xml:</code></para>

      <programlisting>  &lt;servlet&gt;
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
      &lt;param-value&gt;
		  classpath:org/geomajas/spring/geomajasWebContext.xml
        WEB-INF/mycontroller.xml
      &lt;/param-value&gt;
      &lt;description&gt;Spring Web-MVC specific (additional) context files.&lt;/description&gt;
    &lt;/init-param&gt;
    &lt;load-on-startup&gt;3&lt;/load-on-startup&gt;
  &lt;/servlet&gt;

</programlisting>
    </section>

    <section>
      <title>Access your RPC service from the client</title>

      <para>To access your GWT-RPC service, create a proxy as
      usual:<programlisting>service = (MyServiceAsync) GWT.create(MyService.class);
ServiceDefTarget endpoint = (ServiceDefTarget) service;
endpoint.setServiceEntryPoint(GWT.getModuleBaseURL() + "myService");</programlisting></para>
    </section>
  </chapter>

  <chapter id="ch-howto-integrate-zk">
    <title>Integrating a Geomajas application in the ZK framework</title>

    <section>
      <title>Introduction</title>

      <para><ulink url="http://www.zkoss.org/">ZK</ulink> is a general purpose
      web framework that uses a server-side approach to create RIAs. The
      framework is Java-based and has a built-in mechanism to synchronize
      presentation state between client and server based on Ajax requests.
      Geomajas on the other hand is a GIS application framework based on GWT.
      GWT compiles Java code to JavaScript and makes use of Ajax requests and
      a custom serialization mechanism to communicate with the server. There
      is no presentation state on the server and the client is functionally a
      thick client (as opposed to ZK).</para>

      <para>When mixing two frameworks it is generally advisable to wrap UI
      components of the foreign framework in such a way that they become
      indistinguishable from native UI components. This technique is actually
      mandatory for frameworks that take complete control over the HTML
      layout, like ZK. While there is not much information available with
      respect to GWT, we have successfully followed the same technique that
      was used in ZK for Google Maps and JQuery.</para>
    </section>

    <section>
      <title>Integrating GWT widgets in ZK</title>

      <para>ZK allows the creation of custom components. In the 5.0.3 version,
      we need to prepare four types of files in order to create a
      component:</para>

      <itemizedlist>
        <listitem>
          <para>The lang-addon.xml file: Registers the new ZK component</para>
        </listitem>

        <listitem>
          <para>The component file (*.java): Server-side Java component
          object</para>
        </listitem>

        <listitem>
          <para>The widget file (*.js): Client-side JavaScript widget object
          (there is a one-to-one correspondence with the server
          component)</para>
        </listitem>

        <listitem>
          <para>The template files (*.dsp): (optional) molds to generate the
          HTML representation of the client part. Alternatively, a redraw
          method can be defined in the .js file.</para>
        </listitem>

        <listitem>
          <para>The zk.wpd file : Widget Package Descriptor (WPD) file
          describing the information of a package, such as its widget classes
          and external JavaScript files</para>
        </listitem>
      </itemizedlist>

      <para>To represent a GWT widget as a ZK component, a wrapper has to be
      created around the GWT widget. Although both frameworks are Java-based,
      there is no communication possible between both as GWT is client-side
      while ZK is server-side. This means that any wrapping has to be done by
      providing mutual hooks or callback functions in the JavaScript
      files.</para>

      <para>We will now give a more detailed overview of each file and its
      functionalities.</para>

      <para>The lang-addon.xml file is located in the classpath at
      /metainfo/zk/lang-addon.xml. In the lang-addon.xml file, the tag name of
      the new component is determined and the class name of the component and
      its corresponding widget:</para>

      <para><programlisting>&lt;language-addon&gt;
 &lt;addon-name&gt;geomajasmap&lt;/addon-name&gt;
 &lt;language-name&gt;xul/html&lt;/language-name&gt;
 &lt;component&gt;
  &lt;component-name&gt;geomajasmap&lt;/component-name&gt;  &lt;!-- this is the tag name --&gt;
  &lt;component-class&gt;com.xxx.GeomajasComponent&lt;/component-class&gt; &lt;!-- this is the full java class name --&gt;
  &lt;widget-class&gt;com.xxx.GeomajasWidget&lt;/widget-class&gt; &lt;!-- this the 'javascript class' name --&gt;
 &lt;/component&gt;
&lt;/language-addon&gt;</programlisting>The dsp file is optional and contains
      some JavaScript code to write out the HTML representation of the widget.
      We refer to the general <ulink
      url="http://books.zkoss.org/wiki/ZK_Component_Development_Essentials">ZK
      component development documentation</ulink> for more information on this
      file.</para>

      <para>The widget file defines a JavaScript class (or prototype) by
      extending the ZK widget class and is located in the classpath at
      web/js/com/xxx/GeomajasWidget.js. This file has the following
      content:</para>

      <para><programlisting>com.xxx.GeomajasWidget = zk.$extends(zk.Widget, {

 bind_ : function(evt) {
  this.$supers('bind_', arguments);
  // save a reference to this instance for later access by GWT
  this.$class._refs[this.uuid] = this;
 },

 unbind_ : function(evt) {
  this.$supers('unbind_', arguments);
 },

 redraw : function(out) {
  out.push('&lt;div', this.domAttrs_(), '&gt;&lt;/div&gt;');
 }
},  {
  // a static map of (id, instance) pairs, accessible by GWT
  _refs : {}
});</programlisting>The bind_() and unbind_() functions are called to after
      the widget is attached/detached to the DOM tree. It seems a good choice
      to use the bind_() function as the initialization point of the wrapped
      GWT component. We would normally just create the GWT component at this
      point, but, because of a race condition between the ZK and GWT
      JavaScript loads, the GWT part may not be loaded yet. For that reason,
      we register a reference to the component in a static map and let this
      reference be picked up and initialized later on by the GWT code. The
      redraw() function creates an empty div with the correct id.</para>

      <para>The component file is a server side Java class that extends the ZK
      XulElement class. Its main purpose is to act as a relay to the client
      part:</para>

      <para><programlisting>
public class GeomajasComponent extends XulElement {

 static {
  addClientEvent(GeomajasComponent.class, FeatureSelectedEvent.NAME, CE_IMPORTANT);
  ...
 }

 private String featureId;
 
 // server-to-client communication
 public void panToFeature(String featureId) {
  if (featureId != null &amp;&amp; !featureId.equals(this.featureId)) {
   this.featureId = featureId;
   smartUpdate("panToFeature", featureId); // send the update to the client
  }
 }

 @Override
 protected void renderProperties(ContentRenderer renderer) throws java.io.IOException {
  super.renderProperties(renderer);
  render(renderer, "panToFeature", featureId); // mandatory by ZK for batch updates
 }

 // client-to-server communication
 @Override
 public void service(AuRequest request, boolean everError) {
  final String cmd = request.getCommand();

  if (cmd.equals(FeatureDeselectedEvent.NAME)) {
   FeatureDeselectedEvent evt = FeatureDeselectedEvent.getEvent(request);
   Events.postEvent(evt); // post as an application-wide event
  } ...
  else {
   super.service(request, everError);
  }
 }

}
</programlisting>The panToFeature() method can be called from other ZK server
      components to let the map pan to a certain feature. The command is
      forwarded to the client by using the smartUpdate() method. The way ZK
      communicates with its client objects or widgets is by invoking setters
      on the client object. This makes sense for a light weight client object
      but is rather awkward from a GWT viewpoint. In this case, the
      setPanToFeature() function will be called on the GeomajasWidget
      JavaScript object. We will now make sure that this function directly
      calls an equivalent function on the GWT component:</para>

      <para><programlisting>
public class GeomajasMapWrapper {

 private JavaScriptObject object;
 
 private MapWidget map;

 public GeomajasMapWrapper(JavaScriptObject object, String id) {
  this.object = object;
  ...  // create and attach the map to DOM element with the specified id (using BasicWidget.setHtmlElement() for SmartGWT)
  initProperties(object);
 }

 public void panToFeature(String args) {
      // pan to feature implementation
 }

 public native void initProperties(JavaScriptObject object) /*-{
  var _this = this;
  object.setPanToFeature = function (featureId) {
   _this.@com.xxx.client.zk.GeomajasMapWrapper::panToFeature(Ljava/lang/String;)(featureId);
  };
 }-*/;

 public native void forwardFeatureSelected(JavaScriptObject object, String featureId) /*-{
  object.fire("onFeatureSelected",{"featureId" : featureId});
 }-*/;

 ...

 public static native void init() /*-{
  var maps = $wnd.com.xxx.GeomajasWidget._refs;
  for(var uuid in maps) {
   var cmp = maps[uuid];
   @com.xxx.client.zk.GeomajasMapWrapper::new(Lcom/google/gwt/core/client/JavaScriptObject;Ljava/lang/String;)(cmp, cmp.uuid);
  }

  // override the bind function in case GWT was loaded first !
  $wnd.com.keyobs.urbagis.GeomajasWidget.prototype.bind_ = function(evt) {
   this.$supers('bind_', arguments);
   @com.xxx.client.zk.GeomajasMapWrapper::new(Lcom/google/gwt/core/client/JavaScriptObject;Ljava/lang/String;)(this, this.uuid);
  };
 }-*/;
</programlisting>There are multiple JSNI methods in this wrapper class to
      communicate between the GWT and ZK worlds:</para>

      <para>The init() method should be called once. It initializes registered
      references in the GeomajasWidget class by calling the constructor of the
      GeomajasWrapper class itself. It then overrides the bind_() function to
      make sure that any calls to bind_() will have the same effect. This is
      important in case the GWT part was loaded before bind_() was called by
      the ZK framework.</para>

      <para>The initProperties() method will add a relay-function to the ZK
      widget with signature setPanToFeature(). It will forward the
      smartUpdate() from the ZK framework to the GWT method panToFeature() of
      our GWT class.</para>

      <para>The forwardFeatureSelected() method will fire an event from the ZK
      client to the ZK server. This method can be called when a feature is
      selected on the map.</para>
    </section>

    <section>
      <title>Bidirectional communication between the two frameworks</title>

      <para>Communicating from GWT to ZK takes the following steps : GWT event
      -&gt; JSNI call to ZK JavaScript -&gt; server command -&gt; ZK component
      -&gt; ZK event.</para>

      <para>The following code parts are required:</para>

      <itemizedlist>
        <listitem>
          <para>add event listener to GWT widget</para>
        </listitem>

        <listitem>
          <para>add JSNI call to GWT widget to forward the event</para>
        </listitem>

        <listitem>
          <para>add JavaScript function to ZK JavaScript to send the ZK
          command</para>
        </listitem>

        <listitem>
          <para>process the ZK command in the ZK component</para>
        </listitem>

        <listitem>
          <para>fire application event in ZK component</para>
        </listitem>
      </itemizedlist>

      <para>Communicating from ZK to GWT takes the following steps : ZK java
      call -&gt; ZK component -&gt; smartupdate -&gt; ZK JSNI callback -&gt;
      GWT call.</para>

      <para>The following code parts are required:</para>

      <itemizedlist>
        <listitem>
          <para>add event listener to ZK component</para>
        </listitem>

        <listitem>
          <para>add update method to ZK component</para>
        </listitem>

        <listitem>
          <para>add ZK callback function to GWT component</para>
        </listitem>

        <listitem>
          <para>process the ZK callback in the GWT component</para>
        </listitem>
      </itemizedlist>

      <figure>
        <title>Bidirectional communication between ZK and GWT</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/zk-gwt.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>
  </chapter>

  <chapter id="ch-howto-logging">
    <title>Setting up logging to a file</title>

    <para>This is not really Geomajas specific, but as a simple guide, a
    configuration which can be used to setup logging to a file, using logback
    as the logging framework:</para>

    <programlisting>&lt;configuration debug="true"&gt;

  &lt;appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;
    &lt;file&gt;/var/log/ktunaxa/log.txt&lt;/file&gt;
    &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt;
      &lt;!-- rollover daily --&gt;
      &lt;fileNamePattern&gt;/var/log/ktunaxa/log-%d{yyyy-MM-dd}.%i.gz&lt;/fileNamePattern&gt; &lt;!-- zipped! --&gt;  
      &lt;maxHistory&gt;60&lt;/maxHistory&gt; &lt;!-- keep logs two months --&gt;
      &lt;timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"&gt;
        &lt;!-- or whenever the file size reaches 20MB --&gt;
        &lt;maxFileSize&gt;20MB&lt;/maxFileSize&gt;
      &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;
    &lt;/rollingPolicy&gt;

    &lt;encoder&gt;
      &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
      &lt;charset&gt;UTF-8&lt;/charset&gt;
    &lt;/encoder&gt;
  &lt;/appender&gt;

  &lt;logger name="org.geomajas" level="DEBUG"/&gt;

  &lt;root level="INFO"&gt;
    &lt;appender-ref ref="FILE"/&gt;
  &lt;/root&gt;

&lt;/configuration&gt;</programlisting>

    <para>Some comments<itemizedlist>
        <listitem>
          <para>Daily rolling log and also rolls when larger than 20MB.</para>
        </listitem>

        <listitem>
          <para>Previous logs are zipped using gzip.</para>
        </listitem>

        <listitem>
          <para>Two months worth or logs are kept (60 days to be
          precise).</para>
        </listitem>

        <listitem>
          <para>This example does enable debug logging. This is not really
          recommended in production!</para>
        </listitem>

        <listitem>
          <para>The default log level is set to INFO. This is recommended. Do
          not set the logging OFF as this will also hide all warnings and
          errors. If you think INFO is too verbose, use WARN (and maybe start
          a discussion in the project to see whether the log level is correct
          for the messages).</para>
        </listitem>
      </itemizedlist></para>
  </chapter>

  <chapter>
    <title id="ch-howto-snapshots">Using snapshots</title>

    <para>To be able to use snapshots, you have to include the snapshot
    repository in your pom, in the repositories section:</para>

    <example>
      <title>Including the snapshot repository</title>

      <programlisting>&lt;repository&gt;
    &lt;id&gt;Geomajas-latest&lt;/id&gt;
    &lt;name&gt;Geomajas snapshot repository&lt;/name&gt;
    &lt;url&gt;http://repo.geomajas.org/nexus/content/groups/latest/&lt;/url&gt;
    &lt;snapshots&gt;
        &lt;enabled&gt;true&lt;/enabled&gt;
    &lt;/snapshots&gt;
&lt;/repository&gt;</programlisting>
    </example>

    <para>When using geomajas-dep to manage the version of the Geomajas parts
    (which we recommend), you can now overwrite the version of Geomajas parts
    by putting them in the dependencyManagement section
    <emphasis>before</emphasis> the geomajas-dep dependency. For example, to
    use the latest version of back-end, GWT face and staticsecurity, the
    dependencyManagement would look like this (actual versions are from the
    time of writing and may need updating):</para>

    <example>
      <title>Overwriting versions when using geomajas-dep</title>

      <programlisting>&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.geomajas&lt;/groupId&gt;
            &lt;artifactId&gt;geomajas-backend&lt;/artifactId&gt;
            &lt;version&gt;1.14.0-SNAPSHOT&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.geomajas&lt;/groupId&gt;
            &lt;artifactId&gt;geomajas-face-gwt&lt;/artifactId&gt;
            &lt;version&gt;1.11.0-SNAPSHOT&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.geomajas.plugin&lt;/groupId&gt;
            &lt;artifactId&gt;geomajas-plugin-staticsecurity-all&lt;/artifactId&gt;
            &lt;version&gt;1.10.0-SNAPSHOT&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.geomajas&lt;/groupId&gt;
            &lt;artifactId&gt;geomajas-dep&lt;/artifactId&gt;
            &lt;version&gt;1.11.36&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</programlisting>
    </example>
  </chapter>

  <chapter>
    <title>Set up cross-context communication between GWT face and another web
    application</title>

    <para>In some cases it may be necessary to put the Geomajas server on a
    different server node (B) than the one that contains the HTML page (A). As
    long as that node B is located in the same domain, such a situation can be
    handled without taking recourse to cross-domain communication hacks. Two
    measures have to be taken to ensure succesful cross-context
    communication:</para>

    <orderedlist>
      <listitem>
        <para>The GWT face should direct its requests to a different URL. This
        can be done by calling the following method on the
        <code>GwtCommandDispatcher</code> instance: <programlisting>public void setServiceEndPointUrl(String url) </programlisting>The
        url should be the absolute service URL of the cross-context server
        (B)</para>
      </listitem>

      <listitem>
        <para>The cross-context server (B) should have a
        <code>GeomajasController</code> that is especially configured to
        accept the gwt.rpc policy file of the compiled GWT
        client:<programlisting>&lt;bean name="/geomajasService" class="org.geomajas.gwt.server.mvc.GeomajasController"&gt;
 &lt;property name="serializationPolicyLocator"&gt;
  &lt;bean class="org.geomajas.gwt.server.mvc.ResourceSerializationPolicyLocator"&gt;
   &lt;property name="policyRoots"&gt;
    &lt;list&gt;
     &lt;value&gt;WEB-INF/policies/&lt;/value&gt;
    &lt;/list&gt;
   &lt;/property&gt;
  &lt;/bean&gt;
 &lt;/property&gt;
&lt;/bean&gt;
</programlisting>The policy file is the file with extension
        <code>.gwt.rpc</code> that is obtained after the GWT compilation
        process. For the above configuration it should be copied to the folder
        <code>WEB-INF/policies</code> in the web root of B.</para>
      </listitem>
    </orderedlist>

    <para>This solution can also be useful if there is a library conflict
    between the Geomajas backend and other parts of the application. In such
    cases web service communication or communication via javascript may be
    your best option.</para>
  </chapter>
</part>
