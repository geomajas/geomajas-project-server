<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE part PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<!--
  ~ This file is part of Geomajas, a component framework for building
  ~ rich Internet applications (RIA) with sophisticated capabilities for the
  ~ display, analysis and management of geographic information.
  ~ It is a building block that allows developers to add maps
  ~ and other geographic data capabilities to their web applications.
  ~
  ~ Copyright 2008-2010 Geosparc, http://www.geosparc.com, Belgium
  ~
  ~ This program is free software: you can redistribute it and/or modify
  ~ it under the terms of the GNU Affero General Public License as
  ~ published by the Free Software Foundation, either version 3 of the
  ~ License, or (at your option) any later version.
  ~
  ~ This program is distributed in the hope that it will be useful,
  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of
  ~ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ~ GNU Affero General Public License for more details.
  ~
  ~ You should have received a copy of the GNU Affero General Public License
  ~ along with this program.  If not, see <http://www.gnu.org/licenses/>.
  -->
<part id="part-gwt-face">
  <title>GWT face</title>

  <chapter>
    <title>GWT client architecture</title>

    <section>
      <title>Client-server communication</title>

      <para>Client-server communication in Geomajas is executed through a
      series of commands instantiated on the client and executed by the
      server. In the GWT face, all such commands are executed by the
      <code>org.geomajas.gwt.client.command.GwtCommandDispatcher</code>. This
      <code>GwtCommandDispatcher</code> has one single method for
      instantiating such commands and handling the result: the
      <code>execute</code> method.</para>

      <para>The command, required by the execute method
      (<code>GwtCommand</code>), is in fact a wrapper around a
      <code>CommandRequest</code> (see architecture) object, wherein the name
      of the requested command Spring bean is found. Each command expects a
      certain implementation of the <code>CommandRequest</code> and
      <code>CommandResponse</code> objects. Note that these request and
      response objects must also be known server-side, and thus will not be
      packaged within the GWT client packages. As a second parameter for the
      execute method, a <code>CommandCallback</code> object is required that
      will execute it's only method on a successful return of a
      command.</para>

      <para>The execution will immediately return a <code>Deferred</code>
      object, that can be used to add more callback methods, so that when the
      command successfully returns, more than one action can be attached to
      it. Without that <code>Deferred</code> object, the client would have to
      send the same command again to add a new callback method to it.</para>

      <xi:include href="../listing/GwtCommandExecution.xml"
                  xmlns:xi="http://www.w3.org/2001/XInclude" />
    </section>

    <section>
      <title>The Map's model</title>

      <para>As with any GIS framework or application, the most crucial of all
      entities is the Map. A map is represented by the
      <code>org.geomajas.gwt.client.widget.<code>MapWidget</code></code>, but
      is set up using the standard model-view-controller paradigm. The widget
      is the actual view of a map, with <code>Painter</code> objects building
      the display. The user interaction is handled using controllers,
      represented by the <code>GraphicsController</code> interface. The third
      aspect, the model, is represented by the
      <code>org.geomajas.gwt.client.map.<code>MapModel</code></code>.</para>

      <section>
        <title>MapModel</title>

        <para>The definition of the model behind a map
        (<code>org.geomajas.gwt.client.map.<code>MapModel</code></code>). This
        object stores all map metadata and layers, and has an extensive
        arsenal of methods to operate on the layers, or even features.</para>

        <para>Another aspect of the <code>MapModel</code>, is the list of
        events that it fires. Handlers for the following events should be
        added to the <code>MapModel</code>:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>MapModelEvent</emphasis>: This event is fired only
            once; when the <code>MapModel</code> has been properly
            initialized. When a <code>MapWidget</code> is added to the HTML
            page, it automatically triggers an initialization method. This
            will ask the server to supply it with the correct metadata, so
            that the <code>MapModel</code> can actually build it's layers,
            etc. Once this initialization process is done, a
            <code>MapModelEvent</code> will be fired. Add a
            <code>org.geomajas.gwt.client.map.event.MapModelHandler</code> to
            use this.</para>
          </listitem>

          <listitem>
            <para><emphasis>FeatureSelectedEvent</emphasis>: This event is
            fired every time a feature within one of this model's vector
            layers is selected. Add a
            <code>org.geomajas.gwt.client.map.event.FeatureSelectionHandler</code>
            to use this.</para>
          </listitem>

          <listitem>
            <para><emphasis>FeatureDeselectedEvent</emphasis>: This event is
            fired every time a feature within one of this model's vector
            layers is deselected. Add a
            <code>org.geomajas.gwt.client.map.event.FeatureSelectionHandler</code>
            to use this.</para>
          </listitem>

          <listitem>
            <para><emphasis>LayerSelectedEvent</emphasis>: This event is fired
            every time a layer within this model is selected. Add a
            <code>org.geomajas.gwt.client.map.event.LayerSelectionHandler</code>
            to use this.</para>
          </listitem>

          <listitem>
            <para><emphasis>LayerDeselectedEvent</emphasis>: This event is
            fired every time a layer within this model is deselected. Add a
            <code>org.geomajas.gwt.client.map.event.LayerSelectionHandler</code>
            to use this.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>MapView</title>

        <para>Part of a map is this
        <code>org.geomajas.gwt.client.map.MapView</code> object, which
        determines and influences what area is currently visible. Internally
        the <code>MapView</code> has a <code>Camera</code> object that you can
        think of a a satellite that floats above the map. This
        <code>Camera</code> floats at a certain height, on a certain position,
        and this will determine what part of the map is shown.</para>

        <para>But that is not all. The <code>MapView</code> is also aware of
        all matrix transformations that can occur to get objects in world
        coordinates (the coordinate system of the map), onto the correct
        position on the screen, and the other way around. Inside the MapView
        is a transformer
        (<code>org.geomajas.gwt.client.spatial.WorldViewTransformer</code>)
        that is able to transform coordinates, geometries and bounding boxes
        from screen space to world space and back. Also a "pan-space" is
        added. This is a space where it is expected that all ojects have
        already been scaled to the map's current scale, but where the
        translation transformation still needs to occur. This space is used to
        render the layers in, and should normally not be used for other
        purposes.</para>
      </section>

      <section>
        <title>Workflow</title>

        <para>Simply put, workflow in Geomajas determines how editing should
        be handled. A workflow consists of several steps, called activities,
        and the end result can be the persistance of a changes. The package
        is: <code>org.geomajas.gwt.client.map.workflow</code></para>

        <figure>
          <title>Workflow API</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center"
                         fileref="../images/gwtface_workflow.png" width="" />
            </imageobject>
          </mediaobject>
        </figure>

        <para><emphasis role="bold">Activity:</emphasis></para>

        <itemizedlist>
          <listitem>
            <para><emphasis>execute</emphasis>: This method is called by the
            encompassing processor to execute the Activity.</para>
          </listitem>

          <listitem>
            <para><emphasis>getErrorHandler</emphasis>: Get the error handler
            that is specifically tuned for the activity.</para>
          </listitem>
        </itemizedlist>

        <para><emphasis role="bold">WorkflowErrorHandler:</emphasis></para>

        <itemizedlist>
          <listitem>
            <para><emphasis>handleError</emphasis>: Executed when an activity
            throws an exception during execution. The WorkflowProcessor must
            make such this method is executed.</para>
          </listitem>
        </itemizedlist>

        <para><emphasis role="bold">WorkflowContext:</emphasis></para>

        <itemizedlist>
          <listitem>
            <para><emphasis>stopProcess</emphasis>: Informs the
            WorkflowProcessor to stop the processing of activities. It is the
            WorkflowProcessors responsibility to ask for this, and execute no
            more activities when "true" is returned.</para>
          </listitem>

          <listitem>
            <para><emphasis>setSeedData</emphasis>: Provide some seed
            information to the context. This is usually provided at the time
            of workflow kickoff.</para>
          </listitem>
        </itemizedlist>

        <para><emphasis role="bold">WorkflowProcessor:</emphasis></para>

        <itemizedlist>
          <listitem>
            <para><emphasis>supports</emphasis>: Ensures that each activity
            configured in this process is supported. This method should be
            called by implemented subclasses for each Activity that is part of
            the process.</para>
          </listitem>

          <listitem>
            <para><emphasis>doActivities</emphasis>: This method kicks off the
            processing of workflow activities.</para>
          </listitem>

          <listitem>
            <para><emphasis>setActivities</emphasis>: Set a list of Activities
            to be executed in the process. This would also be a good time to
            check if activities are supported.</para>
          </listitem>

          <listitem>
            <para><emphasis>setDefaultErrorHandler</emphasis>: set a default
            error handler, in case an Activity throws an exception without it
            having it's own error handler. In that case, the process' default
            error handler handles the exception.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Selection of features</title>

        <para>A feature in a vector layer has the possibility to be selected.
        Selection usually changes the color of the feature on the map or in a
        table to make it stand out. The actual process of selection is handled
        by the <code>MapModel</code>. In the map model, clones of the selected
        features are stored. After all, it is possible that by moving away
        from a certain area, the selected features are no longer in sight, and
        perhaps no longer in the client layer-cache. Still their contents may
        be needed for specific tasks.</para>

        <para>The <code>MapModel</code> fires events when changes in selection
        occur. It will fire either <code>FeatureSelectedEvent or
        <code>FeatureDeselectedEvent</code></code>. The <code>MapModel</code>
        implements the <code>HasFeatureSelectionHandler</code> interface so
        other components can register with the <code>MapModel</code> as
        <code>FeatureSelectionHandler</code>. For example the
        <code>MapWidget</code> will register itself as a handler so that it
        knows when a feature is selected or deselected and can redraw it
        accordingly.</para>

        <figure>
          <title>Selection events and handlers</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center"
                         fileref="../images/gwtface_selection.png" width="" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>So, when writing code that needs to react upon the selection of
        features, implement the <code>FeatureSelectionHandler</code>
        interface, and register yourself with the
        <code>MapModel</code>.</para>

        <para><note>
            <para>Individual vector layers too can fire selection events.
            Actually the MapModel propagates the events from the individual
            vector layers, so that the user need only install his handlers in
            one place.</para>
          </note></para>
      </section>
    </section>

    <section>
      <title>The spatial package</title>

      <para>The spatial package (<code>org.geomajas.gwt.client.spatial</code>)
      contains a collection of math and geometry related classes and utilities
      to provide all the calculating power one should need. If really complex
      calculations need to be performed, it's best to let the server (JTS)
      handle it anyway. The root of the package contains the general
      mathematical definitions of a Vector, Matrix, LineSegment, and so on. It
      also provides a general math library and the
      <code>org.geomajas.gwt.client.spatial.WorldViewTransformer</code>.</para>

      <para>The <code>WorldViewTransformer</code> in particular can be a very
      valuable tool. It allows for the transforming of coordinates, bounding
      boxes and geometries between the 3 pre-defined spaces (world, view,
      pan). See the rendering manual for more information on the differences
      between these 3 spaces.</para>

      <section>
        <title>Geometry definitions</title>

        <para>All <code>Geometry</code> definitions in the GWT face are based
        upon the geometries from the Java Topology Suite, and can be found in
        the following package:
        <code>org.geomajas.gwt.client.spatial.geometry</code>. These
        geometries in turn have been based upon the OGC simple feature
        specification. Supported geometries are:</para>

        <itemizedlist>
          <listitem>
            <para><code>Point</code>: a geometry representation of a single
            coordinate.</para>
          </listitem>

          <listitem>
            <para><code>MultiPoint</code>: A geometry containing multiple
            <code>Point</code> geometries.</para>
          </listitem>

          <listitem>
            <para><code>LineString</code>: A list of connected coordinates.
            Sometimes also called a polyline.</para>
          </listitem>

          <listitem>
            <para><code>LinearRing</code>: An extension of the
            <code>LineString</code> geometry that expects the last coordinate
            to be equal to the first coordinate. In other words, a
            <code>LinearRing</code> is a closed
            <code>LineString</code>.</para>
          </listitem>

          <listitem>
            <para><code>MultiLineString</code>: A geometry containing multiple
            <code>LineString</code> geometries.</para>
          </listitem>

          <listitem>
            <para><code>Polygon</code>: A <code>Polygon</code> is a two-part
            geometry, consisting of an exterior <code>LinearRing</code> and a
            list of interior <code>LinearRings</code>. The exterior
            <code>LinearRing</code>, also called the shell, is the outer hull
            of the geometry, while the interior rings can be seen as holes in
            the exterior ring's surface area.</para>
          </listitem>

          <listitem>
            <para><code>MultiPolygon</code>: A Geometry containing multiple
            <code>Polygon</code> geometries.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Editing geometries</title>

        <para>The Geometry implementations themselves do not allow any setters
        methods. Instead the editing of geometries is done through a series of
        operations, all implementing the
        <code><code>org.geomajas.gwt.client.spatial.geometry.operation.GeometryOperation</code></code>
        interface. This interface consists of only one method, that takes in a
        geometry, and returns the result in the form of a newly created
        geometry.</para>

        <para>Geometries have no public constructors, so the creation of new
        geometries has to happen trough some factory instance. This is where
        the
        <code>org.geomajas.gwt.client.spatial.geometry.GeometryFactory</code>
        comes into play. A <code>GeometryFactory</code> can be created using a
        spatial reference id and a certain precision, but it can also be
        retrieved from any geometry instance (where srid and precision are
        automatically correct).</para>

        <para><code>GeometryOperation</code> interface:<programlisting>/**
 * General interface for operations on Geometry objects. All operations should return a
 * new Geometry instead of changing the original.
 */
public interface GeometryOperation {

    /**
     * The main edit function. It is passed a geometry object. If other values are needed,
     * pass them through the constructor, or via setters.
     * 
     * @param geometry
     *            The {@link Geometry} object to be adjusted.
     * @return Returns the resulting geometry, leaving the original unharmed.
     */
    Geometry execute(Geometry geometry);
}</programlisting></para>
      </section>

      <section>
        <title>Snapping</title>

        <para>Snapping in Geomajas, is handled by a single manager class
        called the
        <code>org.geomajas.gwt.client.spatial.snapping.Snapper</code>. It is
        the main handler for snapping to coordinates. It supports different
        modes of operating and different algorithms for the actual snapping.
        The different algorithms to use are defined in the vector layer
        configuration files, while the modes are defined by the different
        implementations of the <code>SnappingMode</code> class. Let us first
        start with the different modes:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>ALL_GEOMETRIES_EQUAL</emphasis>: This snapping
            mode considers all geometries equal when it comes to determining
            where to snap to. Depending on the snapping algorithm used, it
            will simply consider all nearby geometries.</para>
          </listitem>

          <listitem>
            <para><emphasis>PRIORITY_TO_INTERSECTING_GEOMETRIES</emphasis>:
            This snapping mode tries to snap to intersecting geometries before
            trying the general approach. When search for a snapping point for
            a given point, this mode will first search for intersecting
            geometries and try to get a snapping point there. If no snapping
            point can be found, it will consider all nearby geometries (just
            like the ALL_GEOMETRIES_EQUAL).</para>
          </listitem>
        </itemizedlist>

        <para>The snapping rules themselves are defined in the XML
        configurations server-side. Each vector layer can have one or many of
        those snapping rules. For each of those rules, 3 fields must be filled
        in:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>layer</emphasis>: The target layer to snap
            to.</para>
          </listitem>

          <listitem>
            <para><emphasis>distance</emphasis>: The distance over which to
            snap. This distance must be expressed in the map's coordinate
            system.</para>
          </listitem>

          <listitem>
            <para><emphasis>type</emphasis>: The actual snapping algorithm to
            use. At the moment 2 types of snapping algorithms are supported:
            to the closest end point (type=1), and to the nearest point
            (type=2). The closest end-point is any point that is actually
            stored in one of the geometries, while the neareest means any
            point on any of the geometries' edges can also be a snapping
            point. Needless to say, the nearest algorithm is heavier then the
            closest point.</para>
          </listitem>
        </itemizedlist>

        <para><emphasis role="bold">Snapping on the map</emphasis></para>

        <para>When a <code>GraphicsController</code> for the map needs to make
        use of snapping (i.e. the editing controllers), then they should
        extend the
        <code>org.geomajas.gwt.client.controller.AbstractSnappingController</code>
        class. This class extends the <code>GraphicsController</code> class
        (the base class for all Geomajas map controllers), and overwrites the
        <code>getScreenPosition</code> and <code>getWorldPosition</code>
        methods so that they can return snapped points instead of actual
        points. The <code>AbstractSnappingController</code> also supports the
        on-the-fly activation and deactivation of snapping.</para>
      </section>
    </section>

    <section>
      <title id="graphics">Graphics &amp; rendering</title>

      <para>In the GWT face, the main <code>render</code>ing method can be
      found in the <code>MapWidget</code>. The render method requires three
      parameters, a paintable object, and target group to paint in and a
      status. The paintable object is the actual object that needs to be
      painted. The target group
      (<code>org.geomajas.gwt.client.widget.MapWidget.RenderGroup</code>)
      specifies where in the DOM to draw. The usual choices here are the
      SCREEN or the WORLD groups. The rendering status
      (<code>org.geomajas.gwt.client.widget.MapWidget.RenderStatus</code>)
      determines what drawing action to take.</para>

      <para><emphasis role="bold">RenderStatus</emphasis></para>

      <para>The render status can be one of the following:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>ALL</emphasis>: completely render or re-render the
          paintable object. If the paintable object contains other paintable
          object, go through them recursively. (a map will paint layers, who
          in turn will paint tiles, ...)</para>
        </listitem>

        <listitem>
          <para><emphasis>UPDATE</emphasis>: update the paintable obect in
          question, but do not update recursively.</para>
        </listitem>

        <listitem>
          <para><emphasis>DELETE</emphasis>: delete the paintable object from
          the map.</para>
        </listitem>
      </itemizedlist>

      <para>While rendering, the map uses a visitor to visit the paintable
      objects recursively and search for painters for each object or
      sub-object. The "ALL" status will paint recursively while the "UPDATE"
      status will not go deeper then the given paintable object. Of course, if
      a given paintable object has no recursive paintable objects, then the
      difference between "ALL" and "UPDATE" is irrelevant.</para>

      <para><emphasis role="bold">RenderGroup</emphasis></para>

      <para>The rendergroup that needs to be specified when calling the map's
      render method, represents the logical place on the map to draw the
      paintable object. There are four choices, each having a huge
      impact.</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>WORLD</emphasis>: Drawing should be done in world
          coordinates. World coordinates means that the map coordinate system
          should be used. The advantage of rendering objects in the world
          group, is that when the user moves the map around, the objects will
          move with it.</para>
        </listitem>

        <listitem>
          <para><emphasis>SCREEN</emphasis>: Drawing should be done in screen
          coordinates. Screen coordinates are expressed in pixels, starting
          from the top left corner of the map. When rendering objects in the
          screen group they will always appear at a fixed position, even when
          the user moves the map about.</para>
        </listitem>

        <listitem>
          <para><emphasis>RASTER</emphasis>: Drawing should be done in pan
          coordinates. All raster layers are drawn in pan coordinates. In
          essence this means that the coordinates are expected to have been
          scaled for the current scale before drawing, and that only the
          translation still needs to occur. For advanced use only.</para>
        </listitem>

        <listitem>
          <para><emphasis>VECTOR</emphasis>: Drawing should be done in pan
          coordinates. All vector layers, their selection and their labels are
          drawn in pan coordinates. In essence this means that the coordinates
          are expected to have been scaled for the current scale before
          drawing, and that only the translation still needs to occur. For
          advanced use only.</para>
        </listitem>
      </itemizedlist>

      <section>
        <title>GFX interfaces</title>

        <para>As will be explained in more detail in the "rendering manual",
        there are 2 ways of drawing on the map: directly using some rendering
        context, or indirectly using <code>Paintable</code> objects,
        <code>Painter</code>s and the <code>MapWidget</code>'s
        <code>render</code> method (as explained above). When using the direct
        approach, one has to call the methods of one of the different
        rendering contexts. A MapWidget contains a MapContext implementation,
        that in turn contains 3 different contexts:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>MenuContext</emphasis>: used for keeping details
            about right mouse clicks....not used for rendering itself.</para>
          </listitem>

          <listitem>
            <para><emphasis>ImageContext</emphasis>: used for rendering images
            in HTML. All rasterlayers use this context.</para>
          </listitem>

          <listitem>
            <para><emphasis>GraphicsContext</emphasis>: the main vector
            graphics renderer. Can also render images, but uses SVG or VML to
            do so. When rendering shapes, circles, rectangle, etc. you will
            always be using this context.</para>
          </listitem>
        </itemizedlist>

        <figure>
          <title>Main context interfaces from the GFX package</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center"
                         fileref="../images/gwtface_gfx_context.png" width="" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>The GraphicsContext is the main vector drawing context. It has 2
        implementations: one for SVG and one for VML.</para>

        <figure id="graphicscontext">
          <title>GraphicsContext interface</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center"
                         fileref="../images/gwtface_graphicscontext.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>Every object that ever appears on a Geomajas map (visually), has
        to implement the <code>Paintable</code> interface. This interface
        marks types of objects that can be painted. For each type/class of
        paintable object, an accompanying <code>Painter</code> must be defined
        as well. The painter will ultimately decide exactly how a paintable
        object should be rendered. The Painter will render objects using it's
        <code>paint</code> method, or delete objects from the map using it's
        <code>deleteShape</code> method.</para>

        <figure>
          <title>General graphics interfaces</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="../images/gwtface_gfx.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <itemizedlist>
          <listitem>
            <para><emphasis>GraphicsContext</emphasis>: This is the basic
            drawing interface. Different implementations will draw in
            different technologies (i.e. <code>SvgGraphicsContext</code> and
            <code>VmlGraphicsContext</code>). The whole idea of this
            <code>GraphicsContext</code> and the painters, has been copied
            from the Java AWT library. This context will draw basic shapes,
            according to their id. Since we are using web technologies, all
            implementations (be they SVG or VML) will use DOM elements to
            create their drawings. Each DOM element in the
            <code>GraphicsContext</code> DOM tree should have an id and a
            parent. This combination of id and parent can later be used to
            update or delete the object.</para>

            <para>In essence, the drawing methods will result in changes in
            the visuals of the map, and it's the painters that will call these
            methods.</para>
          </listitem>

          <listitem>
            <para><emphasis>Paintable</emphasis>: The basic definition of an
            object that can be painted onto the map. For each
            <code>Paintable</code> class, an accompanying <code>Painter</code>
            class must be defined. The <code>Paintable</code> interface has
            only two methods. One to get it's unique identifier within a
            parent group and used by the <code>PainterVisitor</code>. The
            getId method returns the <code>Paintable</code> objects id, which
            is it's key in the DOM tree within the parent group. While the
            accept method will be traversed by the
            <code>PainterVisitor</code>, and used to have the object passed to
            the correct <code>Painter</code>, who will then draw the
            object.</para>
          </listitem>

          <listitem>
            <para><emphasis>WorldPaintable</emphasis>: Extension of the
            <code>Paintable</code> interface for objects that support being
            rendered in world space. This means that it should be possible to
            transform the object's geometry/location/coordinate/bbox.</para>
          </listitem>

          <listitem>
            <para><emphasis>Painter</emphasis>: A <code>Painter</code> knows
            how to paint a specific kind of <code>Paintable</code> object.
            Exactly what class of <code>Paintable</code> objects it can draw,
            must be made clear by it's <code>getPaintableClassName</code>
            method. Furthermore, the <code>Painter</code> has two methods to
            paint or remove <code>Paintable</code> objects on or from the
            given <code>GraphicsContext</code>. Basically, the
            <code>Painter</code> translates the fields and parameters of the
            <code>Paintable</code> object into calls to the
            <code>GraphicsContext</code>.</para>
          </listitem>

          <listitem>
            <para><emphasis>PainterVisitor</emphasis>: Geomajas uses a visitor
            algorithm for it's client side rendering process. The
            <code>MapWidget</code> uses a <code>PainterVisitor</code> to
            recursively traverse the tree of <code>Paintable</code> objects,
            calling the <code>accept</code> method on each node.</para>

            <para>Of course this recursive system of searching for the correct
            <code>Painter</code>, can only work when the
            <code>PainterVisitor</code> has all the necessary painters
            registered. When registering a <code>Painter</code> with the
            <code>MapWidget</code>, it will actually pass it along to this
            <code>PainterVisitor</code> instance.</para>

            <para>An example of the recursive painting, can be found in the
            <code>MapModel</code>, which calls the <code>accept</code> methods
            of it's <code>layers</code>, which call the <code>accept</code>
            methods of the visible <code>tiles</code>, which contain
            <code>features</code>...</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Rendering manual</title>

        <para>As said before, there are 2 ways of rendering object onto the
        map. One uses <code>Paintable</code> objects and
        <code>Painter</code>s, the other is by using the
        <code>GraphicsContext</code> directly. There are still some general
        notions that one must know before attempting to draw on the map. Since
        Html, Svg and Vml are all markup languages who use a DOM tree as basic
        model, rendering basically is the adding and removing of nodes within
        this tree. As parent nodes have styling information or other
        attributes that reflect their child nodes, it is very important to add
        nodes to the correct parent when drawing.</para>

        <para>The <link linkend="graphicscontext">GraphicsContext</link>
        reflects this problem, as all drawing methods requires a parent Object
        as first parameters. Associated with every node is an Object that
        represents it. Given this object, the GraphicsContext can find the
        correct node. When using the GraphicsContext directly, it is important
        to be aware of the necessity of using the correct parent group when
        drawing.</para>

        <section>
          <title>The simple approach - indirect drawing</title>

          <section>
            <title>Drawing in screen space</title>

            <para>This approach uses the MapWidget's render method, which
            requires 3 parameters: a <code>Paintable</code> object, a target
            <code>RenderGroup</code>, and a <code>RenderStatus</code>. If you
            are unfamiliar with these, visit the <link
            linkend="graphics">beginning of this chapter</link> for a detailed
            description.</para>

            <para>Let us start with an example, where we draw a rectangle in
            screen space (=pixel coordinates). The code would look something
            like this:</para>

            <programlisting>Rectangle rectangle = new Rectangle("myRectangle");
rectangle.setBounds(new Bbox(10, 10, 200, 200));
rectangle.setStyle(new ShapeStyle("#FF0000", .8f, "#0000FF", .6f, 2));

map.render(rectangle, RenderGroup.SCREEN, RenderStatus.ALL);</programlisting>

            <para>This code snippet would draw a rectangle (= Paintable),
            called "myRectangle" in screen space (10 pixels from the top, 10
            pixels from the left, and with a width and height of both 200),
            using the defined style (red interior with a blue border). To
            delete the rectangle again, you would have to do something like
            this:</para>

            <programlisting>map.render(rectangle, RenderGroup.SCREEN, RenderStatus.DELETE);</programlisting>
          </section>

          <section>
            <title>Drawing in world space</title>

            <para>Remember that there was also an extension of the
            <code>Paintable</code> interface, designed for rendering objects
            in world space. Rendering in world space means that objects are
            drawn in the coordinate system of the map (EPSG:????). This also
            means that when the user moves about on the map, the object will
            move with it (keeping the same location in map coordinates). Only
            objects that implement the <code>WorldPaintable</code> interface
            can be drawn in world space.</para>

            <para>Let us, for the next example, assume that the map has been
            defined using EPSG:4326 (latlon) as coordinate system, and we
            would apply the following code snippet:</para>

            <programlisting>Rectangle rectangle = new Rectangle("myRectangle");
rectangle.setBounds(new Bbox(-60, -60, 120, 120));
rectangle.setStyle(new ShapeStyle("#FF0000", .8f, "#0000FF", .6f, 2));

// Register the rectangle to the map, so that it gets redrawn
// automatically when the user navigates on the map.
map.getWorldSpacePaintables().add(rectangle);

// Just update the map, so that the new rectangle is drawn:
map.render(null, RenderGroup.WORLD, RenderStatus.UPDATE);</programlisting>

            <para>Starting from -60, -60 and using a width and height of 120,
            we would have a rectangle that encompasses a huge part of the
            world. Note that drawing objects in world space requires you to
            register them with the map. This is necessary to have the map
            automatically update the object's position when the user
            navigates. After the registration of the
            <code>WorldPaintable</code> rectangle, the map is redrawn to have
            the rectangle become visible. By giving a null as first parameter,
            the map will assume that it's <code>MapModel</code> needs
            re-rendering.</para>
          </section>
        </section>

        <section>
          <title>The advanced approach - using the GraphicsContext
          directly</title>

          <para>When more flexibility is required from the rendering system,
          the map's render method might sometimes not be enough. If for
          example we want to render more than one object within a specific
          parent group. The following code snippet shows how to render a
          specific parent in screen space and then render a circle within this
          parent group:</para>

          <programlisting>// Create a parent group within screen space:
Composite parent = new Composite("myParent");
map.getVectorContext().drawGroup(map.getGroup(RenderGroup.SCREEN), parent);

// Draw a circle at (20, 20) with radius 10 pixels within parent group:
Coordinate pos = new Coordinate(20, 20);
ShapeStyle style = new ShapeStyle("#FF0000", .8f, "#0000FF", .6f, 2);
map.getVectorContext().drawCircle(parent, "myCircle", pos, 10, style);</programlisting>

          <para>Since no special parameters are added to the "myParent" node,
          the circle is drawn as if it were in the screen group itself. But
          thanks to the extra parent group, we now have the ability for apply
          specific styling or transformations on that parent group, and thus
          altering all children within it. Let us for example move the circle
          100 pixels to the right:</para>

          <programlisting>// Translate the parent group 100 pixels to the right:
Matrix m = new Matrix(1, 0, 0, 1, 100, 0);
map.getVectorContext().drawGroup(map.getGroup(RenderGroup.SCREEN), parent, m);</programlisting>

          <warning>
            <para>Do not try to render objects in world space when using the
            <code>GraphicsContext</code> directly. Behind the screens of the
            <code>MapWidget</code>, the world space objects are actually
            transformed and rendered in VECTOR space. This is done to avoid
            scaling in the DOM tree (Vml has problems with it...).</para>
          </warning>
        </section>
      </section>
    </section>

    <section>
      <title id="interaction">User interaction</title>

      <para>This section covers the many interfaces regarding buttons, menu
      items and such that make up the user interface. The specific Geomajas
      widgets (i.e. LayerTree) require a specific way of doing things. In the
      next sections, we will cover the interfaces for the Toolbar, LayerTree,
      map controllers and context menus.</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Toolbar</emphasis>: The toolbar has 2 types of
          default actions one can add to it (there is always the
          <code>addChild</code> method, which can add any widget, but we are
          now talking about Geomajas specific possibilities): the
          <code>ToolbarAction</code> and the <code>ToolbarModalAction</code>.
          The <code>ToolbarAction</code> is used for actions that need
          immediate response upon clicking, while the
          <code>ToolbarModalAction</code> is used for enabling or disabling a
          certain state.</para>
        </listitem>

        <listitem>
          <para><emphasis>LayerTree</emphasis>: The <code>LayerTree</code> has
          the possibility to add buttons to it's toolbar that usually act upon
          the selected layer within the <code>LayerTree</code>. Again 2 types
          of actions can be added: the <code>LayerTreeAction</code> and the
          <code>LayerTreeModalAction</code>. The same difference as with the
          toolbar applies: the <code>LayerTreeAction</code> is a base abstract
          class for actions that execute immediately upon clicking, while the
          <code>LayerTreeModalAction</code> is used for enabling or disabling
          a certain state (for example: toggle the layer's visibility).</para>
        </listitem>

        <listitem>
          <para><emphasis>Menu</emphasis>: Each item in a context menu can
          (should) extend the MenuAction base class. This is your basic
          starting point for easily creating new menu items or context menu
          items.</para>
        </listitem>

        <listitem>
          <para><emphasis>Controllers on the map</emphasis>: For controllers
          listening to mouse events on a map, there is the
          <code>GraphicsController</code> interface, or an abstraction under
          the name of <code>AbstractGraphicsController</code>.</para>
        </listitem>
      </itemizedlist>

      <note>
        <para>For buttons in the <code>Toolbar</code> or
        <code>LayerTree</code> it is possible to add them to the
        <code>org.geomajas.gwt.client.action.toolbar.ToolbarRegistry</code> or
        <code>org.geomajas.gwt.client.action.layertree.LayerTreeRegistry</code>
        upon application startup (before the MapWidget initialization!). This
        will allow you to use these new buttons in the server side XML
        configuration.</para>
      </note>

      <section>
        <title>Toolbar: ToolbarAction</title>

        <para>The <code>ToolbarAction</code> is your basic abstract class for
        building toolbar buttons that are executed immediately when clicked.
        That is why this class implements the <code>ClickHandler</code>
        interface. It also requires your to specify an icon and a tooltip on
        creation.</para>

        <para><code>ToolbarAction</code> classes need to be registered in the
        <code><code>ToolbarRegistry</code></code> class. This allows you to
        get an instance of the widget to put in the toolbar. The tools which
        are always part of the GWT face are statically defined in the class.
        Other tools can be added (or overwritten) at runtime before the map is
        initialised.</para>

        <para>When a <code>ToolbarAction</code> is configurable (XML
        configuration), it should implement the
        <code>ConfigurableAction</code> interface. This contains a
        "<code>configure()</code>" method which will be called for each of the
        parameters which are defined in the tool configuration.</para>

        <programlisting>/**
 * Abstract class that serves as a template for building toolbar actions. A toolbar 
 * action is an action that is executed immediately when the toolbar button is clicked.
 * If you want a selectable toolbar button, have a look at the {@link ToolbarModalAction}
 * class.
 */
public abstract class ToolbarAction extends ToolbarBaseAction implements ClickHandler {

    public ToolbarAction(String icon, String tooltip) {
        super(icon, tooltip);
    }
}



/**
 * Base toolbar action, defines the common bits between {@link ToolbarAction} and
 * {@link ToolbarModalAction}.
 */
public abstract class ToolbarBaseAction {

    /** Link to the image icon that should represent the action's button in the toolbar. */
    private String icon;

    /** Text that appears when hovering over the toolbar button. */
    private String tooltip;

    /** Is the button for this action disabled or not? */
    private boolean disabled;

    private HandlerManager handlerManager;

    // Constructors:

    public ToolbarBaseAction(String icon, String tooltip) {
        this.icon = icon;
        this.tooltip = tooltip;
        handlerManager = new HandlerManager(this);
    }

    // Public methods:

    public HandlerRegistration addToolbarActionHandler(ToolbarActionHandler handler) {
        return handlerManager.addHandler(ToolbarActionHandler.TYPE, handler);
    }

    // Getters and setters:

    /** Link to the image icon that should represent the action's button in the toolbar. */
    public String getIcon() {
        return icon;
    }

    /**
     * Link to the image icon that should represent the action's button in the toolbar.
     * 
     * @param icon
     *            The new icon value
     */
    public void setIcon(String icon) {
        this.icon = icon;
    }

    /** Text that appears when hovering over the toolbar button. */
    public String getTooltip() {
        return tooltip;
    }

    /**
     * Text that appears when hovering over the toolbar button.
     * 
     * @param tooltip
     *            The new tooltip value
     */
    public void setTooltip(String tooltip) {
        this.tooltip = tooltip;
    }

    /** Is the button for this action disabled or not? */
    public boolean isDisabled() {
        return disabled;
    }

    /**
     * Is the button for this action disabled or not?
     * 
     * @param disabled
     *            The new value
     * */
    public void setDisabled(boolean disabled) {
        this.disabled = disabled;
        if (disabled) {
            handlerManager.fireEvent(new ToolbarActionDisabledEvent());
        } else {
            handlerManager.fireEvent(new ToolbarActionEnabledEvent());
        }
    }
}</programlisting>
      </section>

      <section>
        <title>Toolbar: ToolbarModalAction</title>

        <para>The <code>ToolbarModalAction</code> is the basic template for
        creating selectable toolbar buttons. Usually they enable and disable a
        certain state on the map when selected or deselected. Many of the
        implementations that come with Geomajas simple set a new controller on
        the map when they are selected.</para>

        <para>Also notice that only one of these
        <code>ToolbarModalActions</code> can be selected at any given time. In
        that sense they act as a radio button.</para>

        <para><code>ToolbarModalAction</code> classes need to be registered in
        the <code><code>ToolbarRegistry</code></code> class. This allows you
        to get an instance of the widget to put in the toolbar. The tools
        which are always part of the GWT face are statically defined in the
        class. Other tools can be added (or overwritten) at runtime before the
        map is initialised.</para>

        <para>When a <code>ToolbarAction</code> is configurable, it should
        implement the <code>ConfigurableAction</code> interface. This contains
        a "<code>configure()</code>" method which will be called for each of
        the parameters which are defined in the tool configuration.</para>

        <programlisting>/**
 * Abstract class which serves as a template for selectable buttons in a toolbar. These
 * selectable buttons can be selected and deselected. With each of these actions a 
 * different method is executed. Usually this type of toolbar button is used to set a new
 * controller onto the {@link org.geomajas.gwt.client.widget.MapWidget}. If you are looking
 * for an action that should be executed immediately when clicking on it, have a look at
 * the {@link org.geomajas.gwt.client.action.ToolbarAction} class.
 */
public abstract class ToolbarModalAction extends ToolbarBaseAction {

    public ToolbarModalAction(String icon, String tooltip) {
        super(icon, tooltip);
    }

    // Class specific actions:

    /**
     * When the toolbar button is selected, this method will be called.
     */
    public abstract void onSelect(ClickEvent event);

    /**
     * When the toolbar button is deselected, this method will be called.
     */
    public abstract void onDeselect(ClickEvent event);
}</programlisting>
      </section>

      <section>
        <title>LayerTree: LayerTreeAction</title>

        <para>The <code>LayerTreeAction</code> is your basic abstract class
        for building layer tree buttons that are executed immediately when
        clicked. To this end, it has an onClick method that needs to be
        implemented and it also requires your to specify an icon, a tooltip
        and a disabled-icon on creation. Note that the onClick method gives
        the selected layer within the <code>LayerTree</code> as a
        parameter.</para>

        <para><code>LayerTreeAction</code> classes need to be registered in
        the <code><code>LayerTreeRegistry</code></code> class. The tools which
        are always part of the GWT face are statically defined in the class.
        Other tools can be added (or overwritten) at runtime before the map is
        initialised.</para>

        <programlisting>/**
 * Base definition of an action for the LayerTree toolbar.
 */
public abstract class LayerTreeAction extends ToolbarBaseAction {

    /**
     * Icon shown when the button is disabled.
     */
    private String disabledIcon;

    /**
     * Constructor setting all values.
     *
     * @param icon
     *            The default icon for the button.
     * @param tooltip
     *            The default tooltip for the button.
     * @param disabledIcon
     *            The icon used when the button is disabled.
     */
    public LayerTreeAction(String icon, String tooltip, String disabledIcon) {
        super(icon, tooltip);
        this.disabledIcon = disabledIcon;
    }

    // Public methods:

    /**
     * This method will be called when the user clicks on the button.
     *
     * @param layer
     *            The currently selected layer.
     */
    public abstract void onClick(Layer&lt;?&gt; layer);

    /**
     * When the toolbar button is selected, this method will be called.
     */
    public abstract boolean isEnabled(Layer&lt;?&gt; layer);

    // Getters and setters:

    public String getDisabledIcon() {
        return disabledIcon;
    }

    public void setDisabledIcon(String disabledIcon) {
        this.disabledIcon = disabledIcon;
    }
}</programlisting>
      </section>

      <section>
        <title>LayerTree: LayerTreeModalAction</title>

        <para>The <code>LayerTreeModalAction</code> is the basic template for
        creating selectable layer tree buttons. Usually they enable and
        disable a certain state for the selected layer within the layer tree
        (for example that layer's visibility).</para>

        <para><code>LayerTreeModalAction</code> classes need to be registered
        in the L<code><code>ayerTreeRegistry</code></code> class. The tools
        which are always part of the GWT face are statically defined in the
        class. Other tools can be added (or overwritten) at runtime before the
        map is initialised.</para>

        <programlisting>/**
 * Base template for modal action in the layer tree toolbar.
 */
public abstract class LayerTreeModalAction extends ToolbarBaseAction {

    private String selectedIcon;

    private String disabledIcon;

    private String selectedTooltip;

    // Constructors:

    public LayerTreeModalAction(String selectedIcon, String deselectedIcon, String disabledIcon,
            String selectedTooltip, String deselectedTooltip) {
        super(deselectedIcon, deselectedTooltip);
        this.selectedIcon = selectedIcon;
        this.disabledIcon = disabledIcon;
        this.selectedTooltip = selectedTooltip;
    }

    // Class specific methods:

    /**
     * When the toolbar button is selected, this method will be called.
     */
    public abstract boolean isEnabled(Layer&lt;?&gt; layer);

    /**
     * When the toolbar button is deselected, this method will be called.
     */
    public abstract boolean isSelected(Layer&lt;?&gt; layer);

    public abstract void onDeselect(Layer&lt;?&gt; layer);

    public abstract void onSelect(Layer&lt;?&gt; layer);

    // Getters and setters:

    public String getSelectedIcon() {
        return selectedIcon;
    }

    public void setSelectedIcon(String selectedIcon) {
        this.selectedIcon = selectedIcon;
    }

    public String getDeselectedIcon() {
        return getIcon();
    }

    public void setDeselectedIcon(String deselectedIcon) {
        setIcon(deselectedIcon);
    }

    public String getSelectedTooltip() {
        return selectedTooltip;
    }

    public void setSelectedTooltip(String selectedTooltip) {
        this.selectedTooltip = selectedTooltip;
    }

    public String getDeselectedTooltip() {
        return getTooltip();
    }

    public void setDeselectedTooltip(String deselectedTooltip) {
        setTooltip(deselectedTooltip);
    }

    public String getDisabledIcon() {
        return disabledIcon;
    }

    public void setDisabledIcon(String disabledIcon) {
        this.disabledIcon = disabledIcon;
    }
}</programlisting>
      </section>

      <section>
        <title>Menu: MenuAction</title>

        <para>When creating menu items or context menu items, Geomajas
        provides a simple base class from which to start. It extends upon the
        basic SmartGWT <code>MenuItem</code> class, but immediately requires
        you to fill in a title and an icon. It also implements the
        <code>ClickHandler</code> interface for defining the
        <code>onClick</code> execution function.</para>

        <programlisting>/**
 * General definition of a &lt;code&gt;MenuAction&lt;/code&gt;. All Geomajas actions in toolbars or
 * context menus should build upon this class.
 */
public abstract class MenuAction extends MenuItem implements ClickHandler {

    /**
     * Constructor that expects you to immediately fill in the title and the icon.
     * 
     * @param title
     *            The textual title of the menu item.
     * @param icon
     *            A picture to be used as icon for the menu item.
     */
    protected MenuAction(String title, String icon) {
        super(title, icon);
        addClickHandler(this);
    }
}</programlisting>
      </section>

      <section>
        <title>Controllers on the map</title>

        <para>For interactive mouse listeners on the map there is a general
        interface, called <code>GraphicsController</code>. This interface
        defines the list of methods one needs to implements when writing a
        custom controller.</para>

        <caution>
          <para>The <code>GraphicsController</code> interface does NOT use
          SmartGWT events! The reason for this is that they provide no way of
          getting the target DOM element from the mouse events. So the list of
          handlers that the <code>GraphicsController</code> extends, are all
          basic GWT event handlers. For this reason, a separate widget
          (<code>GraphicsWidget</code>) has been created to catch the events,
          while the normal <code>MapWidget</code> (which encapsulates the
          <code>GraphicsWidget</code>) can still handle SmartGWT
          events.</para>
        </caution>

        <para>On top of all the event handling methods that come from the
        different handlers, the interface also has an <code>onActivate</code>
        and an <code>onDeactivate</code> method. The <code>onActivate</code>
        method is called before the controller is actually applied on the
        <code>GraphicsWidget</code>. This is usually used to apply a new
        context menu on the map and such. The <code>onDeactivate</code> method
        is called when the controller is removed from the
        <code>GraphicsWidget</code>. This is usually used for cleaning up it's
        own mess.</para>

        <programlisting>/**
 * General interface for a controller set on a {@link MapWidget}. It should implement all
 * of the available mouse handling events.
 */
public interface GraphicsController extends MouseDownHandler, MouseUpHandler,
        MouseMoveHandler, MouseOutHandler, MouseOverHandler, MouseWheelHandler,
        DoubleClickHandler {

    /**
     * Function executed when the controller instance is applied on the map.
     */
    void onActivate();

    /**
     * Function executed when the controller instance is removed from the map.
     */
    void onDeactivate();
}</programlisting>

        <para>An interface being what it is, it may be handy to have a
        starting point with some added shortcut methods. This is where the
        <code>AbstractGraphicsController</code> comes in. This abstract class
        implements all methods as empty methods so you don't have to clutter
        your code with empty methods yourself (often only a few of the mouse
        event methods are actually used). On top of that, this class has some
        extra methods for return useful information for the mouse events, such
        as the position (expressed in screen coordinates) or the target DOM
        element.</para>

        <para>Small extract from the <code>AbstractGraphicsController</code>
        class:</para>

        <programlisting>    // -------------------------------------------------------------------------
    // Helper functions on mouse events:
    // -------------------------------------------------------------------------

    protected Coordinate getPosition(MouseEvent&lt;?&gt; event) {
        return GwtEventUtil.getPosition(event);
    }

    protected Element getTarget(MouseEvent&lt;?&gt; event) {
        return GwtEventUtil.getTarget(event);
    }

    protected String getTargetId(MouseEvent&lt;?&gt; event) {
        return GwtEventUtil.getTargetId(event);
    }</programlisting>

        <para>Now that you have your controller you can set it;</para>

        <programlisting>    mapWidget.setController(new MeasureDistanceController(mapWidget));</programlisting>

        <note>
          <para>There are more abstractions than just the
          AbstractGraphicsController:</para>

          <itemizedlist>
            <listitem>
              <para><emphasis><code>AbstractRectangleController</code></emphasis>:
              abstract controller that handles drawing a rectangle by dragging
              the mouse on the map.</para>
            </listitem>

            <listitem>
              <para><emphasis><code>AbstractSnappingController</code></emphasis>:
              abstract controller that allows snapping to be enabled and
              disabled. When enabled, the returned points when asking
              <code>getPosition()</code>, are snapped points (depending on the
              configured snapping rules).</para>
            </listitem>
          </itemizedlist>
        </note>
      </section>
    </section>

    <section>
      <title>Internationalization in Geomajas</title>

      <para>For the concept of internationalization, Geomajas uses the default
      GWT i18n implementation. No need to reinvent the wheel. For more
      information on how to use GWT i18n in general, please consult the GWT
      documentation. For Geomajas specifically, the i18n is used in several
      places, each having it's own list of messages. Basically all i18n
      message definitions are located in the package
      <code>org.geomajas.gwt.client.i18n</code>, as are the properties files
      containing the translations.</para>

      <para>Several separate definitions have been created:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>MenuMessages</emphasis>: The
          <code>MenuMessages</code> defines parametrized string values that
          are used in the titles of <action>MenuAction</action> classes.
          Examples are the editing context menus.</para>
        </listitem>

        <listitem>
          <para><emphasis>ToolbarConstants</emphasis>: The
          <code>ToolbarConstants</code> defines constant string values that
          are used as tooltips when hovering over the buttons in the Toolbar.
          This list of values is used by the <code>ToolbarAction</code> and
          <code>ToolbarSelectAction</code> classes. Note that for tooltips the
          "&amp;nbsp;" character is used instead of the default space.</para>
        </listitem>

        <listitem>
          <para>..........</para>
        </listitem>
      </itemizedlist>

      <para>To avoid multiple instantiations of the constants and messages
      classes and have a central access point for all internationalization
      concerns, the I18nProvider class has been created. This class has static
      methods for accessing the constants and messages classes. Usage is as
      follows:</para>

      <programlisting>String dist = I18nProvider.getMenu().getMeasureDistanceString(totalDistance, radius); 
setContents( "&lt;div&gt;&lt;b&gt;" + I18nProvider.getMenu().distance() + "&lt;/b&gt;:&lt;/div&gt;&lt;div style='margin-top:5px;'&gt;" + dist + "&lt;/div&gt;"); </programlisting>
    </section>
  </chapter>

  <chapter id="chapter-gwt-widgets">
    <title>GWT widgets</title>

    <para>This second chapter of the GWT face describes all the widgets that
    Geomajas has added on top of the SmartGWT widget list. Each widget will be
    handled in detail so that developers might get a better understanding of
    what they are here for, and how to use them. Know that many of these
    widgets are closely connected, either through configuration or
    coding.</para>

    <section>
      <title>GraphicsWidget</title>

      <para>The <code>GraphicsWidget</code> is the basic widget that allows
      drawing onto a <code>GraphicsContext</code>, and catches mouse events at
      the same time. It implements the <code>MapContext</code> interface and
      provides it's own <code>MenuContext</code> implementation. As for the
      <code>VectorContext</code>, it delegates to a browser specific
      implementation (<code>VmlGraphicsContext</code> or
      <code>SvgGraphicsContext</code>). It is also responsible for handling
      <code>GraphicsController</code>s (only one global controller at a
      time!). The reason to place the controller handling here, is because we
      needed a default GWT widget to handle the events, not a SmartGWT widget.
      The SmartGWT events do not contain the actual DOM elements for
      MouseEvents, while the default GWT events do - for some functionality it
      is absolutely vital that it is well-known which DOM node was the target
      of an event.</para>

      <para>Using the MenuContext, this widget always has the coordinates of
      the latest right mouse click. Usually the right mouse button is used for
      drawing context menus. But sometimes it is necessary to have the DOM
      element onto which the context menu was clicked, to influence this menu.
      That is why this widget always stores this latest event (or at least
      it's DOM element id, and screen location).</para>

      <para>This widget is the bridge between the internal Svg or Vml
      rendering in GWT and the SmartGWT widget library. It is used internally
      in the MapWidget, but is not meant to be used directly by
      developers.</para>
    </section>

    <section>
      <title>MapWidget</title>

      <para>The main map for any Geomajas application using the GWT face. This
      widget controls the <code>MapModel</code>, the <code>MapView</code>
      objects, has an internal <code>GraphicsWidget</code> for the actual
      rendering, and much more. Being the most central of all widget, the
      MapWidget has quite a few responsibilities and options.</para>

      <para><emphasis role="bold">Map - initialization</emphasis></para>

      <para>A first responsibility of the map is the correct initialization of
      it's model and all layers from the server-side XML configuration. When
      the MapWidget is added to the HTML (onDraw), it will automatically try
      and find a configuration from the server, and than initialize itself (or
      more importantly, build it's MapModel). When this is done, the MapModel
      will fire a <code>MapModelEvent</code>. This event let's everyone know
      that the initialization has been done successfully. Many other widgets
      wait for this moment to initialize themselves, as they often require the
      MapModel's contents.</para>

      <para><emphasis role="bold">View - rendering</emphasis></para>

      <para>A second responsibility lies in the ability to render shapes. To
      this end a render method has been foreseen, where a
      <code>PainterVisitor</code> will recursively go through
      <code>Paintable</code> objects and look for the correct
      <code>Painter</code>. All Painter definitions must be registered in the
      <code>MapWidget</code>, by means of the "<code>registerPainter</code>"
      and "<code>unregisterPainter</code>" methods. Also the full list of
      <code>WorldPaintables</code> is stored within the
      <code>MapWidget</code>. For more information regarding the rendering,
      using the render method, visit the <link
      linkend="graphics"><corpauthor>rendering
      manual</corpauthor></link>.</para>

      <para>As an addition of the <code>Paintable</code> objects in
      screen-space, the definition of a <code>MapAddon</code> has been created
      as well. <code>MapAddons</code> are selfregulating pieces of software
      that are visible at a certain location on the map (in screen space!),
      and optionally have attached behaviour. Examples are the Navigation
      buttons and the scalebar.</para>

      <para><emphasis role="bold">Controller</emphasis></para>

      <para>A map without interactivity is quite meaningless, and so in order
      to attach behaviour to the map, it is possible to apply a controller.
      Two types of controllers are supported by the map: the
      <code>GraphicsController</code> and the GWT
      <code>MouseWheelHandler</code>. For both it is possible to apply a
      single instance using the <code>setController</code> and
      <code>setMouseWheelController</code> methods.</para>

      <para><emphasis role="bold">Options</emphasis></para>

      <para>On top of the previous list of responsibilities, the map also has
      a few options that allow certain functionality to be present or not. The
      following options come out of the box:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>navigationAddonEnabled</emphasis>: This option can
          be configured from within the XML configuration, and determines
          whether or not the navigation <code>MapAddon</code> is visible. This
          <code>MapAddon</code> is placed in the upper left corner of the map
          andallows the user to pan, zoom in and out, and zoom to maximum
          extent.</para>
        </listitem>

        <listitem>
          <para><emphasis>scaleBarEnabled</emphasis>: This option can be
          configured from within the XML configuration, and determines whether
          or not the scalebar <code>MapAddon</code> is visible. The scalebar
          shows you the scale of the map by means of a bar of certain length,
          expressed in the preferred unit type (metric versus English).</para>
        </listitem>

        <listitem>
          <para><emphasis>zoomOnScrollEnabled</emphasis>: This option
          determines whether or not the <code>ZoomOnScrollController</code> is
          active by default. The <code>ZoomOnScrollController</code> zoom in
          and out on the map by using the mousewheel.</para>
        </listitem>
      </itemizedlist>

      <figure>
        <title>MapWidget example</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center"
                       fileref="../images/gwtface_widget_mapwidget.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>OverviewMap</title>

      <para>The overview map is an extension of the <code>MapWidget</code>,
      that keeps the overview of a target <code>MapWidget</code>. It keeps
      track of the target map's view, and reacts whenever that target map
      changes it's view. The <classname>OverViewMap</classname> implements the
      <code>MapViewChangedHandler</code> to track the changes of it's target
      map. Since it's an extension of a normal <code>MapWidget</code>, it has
      all the functionality a normal map has. This means that you configure
      layers for an overview map, just as you would for a normal map.</para>

      <figure>
        <title>OverviewMap example</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center"
                       fileref="../images/gwtface_widget_overviewmap.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Toolbar</title>

      <para>The Geomajas toolbar is an extension of the SmartGWT ToolStrip
      widget, and thus allows for many different widgets to be added to it. A
      toolbar must also be initialized with a pointer to the MapWidget it is
      related to. When the MapWidget has successfullu initialized itself, it's
      MapModel will fire the MapModelEvent saying so. The toolbar reacts on
      this event, by searching in the map's configuration for the correct list
      of toolbar-buttons. After all, the map configuration can contain tool
      ids to indicate the tools which need to be added, together with optional
      parameters. Using the ToolbarRegistry, which contains the mappings
      between these id's and the relevant <code>ToolbarAction</code> or
      <code>ToolbarModalAction</code> classes, the toolbar will initialize
      itself (for more info; see <link linkend="interaction">User
      Interaction</link>).</para>

      <para>Existing tools which can be defined include:</para>

      <para><itemizedlist>
          <listitem>
            <para><emphasis>EditMode</emphasis>: Adds a ToolbarModalAction
            meant for editing on the map. Allows for the creation of new
            object within the selected layer, and allows for updating and
            deleting of selected objects.</para>
          </listitem>

          <listitem>
            <para><emphasis>MeasureDistanceMode</emphasis>: Adds a
            ToolbarModalAction that allows the user to measure distances on
            the map.</para>
          </listitem>

          <listitem>
            <para><emphasis>SelectionMode</emphasis>: allow selecting features
            either by clicking on them, or by dragging a rectangle, thus
            selecting the features which are inside the rectangle. You need an
            active (vector) layer for the selection to work. The right click
            menu allows clearing the selected features and toggling selection
            of the current position. Keeping shift depressed allows you to add
            the selection to the previously selected features. Possible
            parameters:</para>

            <para><itemizedlist>
                <listitem>
                  <para><emphasis>clickTimeout</emphasis>: when the button it
                  released in less than the number of milliseconds specified
                  here, then the selection is treated as a click. When it
                  takes longer, it is treated as dragging. Default is "500"
                  (ms).</para>
                </listitem>

                <listitem>
                  <para><emphasis>coverageRatio</emphasis>: ration of the
                  feature which needs to be inside the selected are for the
                  feature to be selected. When this is "1.0" then the entire
                  feature needs to be inside the selection rectangle. Default
                  is "0.7".</para>
                </listitem>

                <listitem>
                  <para><emphasis>priorityToSelectedLayer</emphasis>: Activate
                  or disable priority to the selected layer. This works only
                  if there is a selected layer, and that selected layer is a
                  <code>VectorLayer</code>. If all these checks are okay, but
                  that particular layer is not visible, then nothing will
                  happen. When one of the previous checks is not okay, the
                  selection toggle will occur on the first object that is
                  encountered. In other words it will depend on the layer
                  drawing order, starting at the top.</para>
                </listitem>

                <listitem>
                  <para><emphasis>pixelTolerance</emphasis>: Number of pixels
                  that describes the tolerance allowed when trying to select
                  features.</para>
                </listitem>
              </itemizedlist></para>
          </listitem>

          <listitem>
            <para><emphasis>ZoomIn</emphasis>: zoom in to the map at the
            location clicked (will be centered), using the zoom factor which
            is configured.</para>

            <para><itemizedlist>
                <listitem>
                  <para><emphasis>delta</emphasis>: zoom in factor, should be
                  &gt;1 to effectively zoom in.</para>
                </listitem>
              </itemizedlist></para>
          </listitem>

          <listitem>
            <para><emphasis>ZoomOut</emphasis>: zoom out of the map at the
            location clicked (will be centered), using the zoom factor which
            is configured.</para>

            <para><itemizedlist>
                <listitem>
                  <para><emphasis>delta</emphasis>: zoom in factor, should be
                  in the ]0,1[ range to effectively zoom out</para>
                </listitem>
              </itemizedlist></para>
          </listitem>

          <listitem>
            <para><emphasis>PanMode</emphasis>: This action allows you to pan
            the screen by dragging. When keeping either the shift or control
            key pressed, it is also possible to indicate an area to zoom into
            (like <emphasis>ZoomToRectangleMode</emphasis>).</para>
          </listitem>

          <listitem>
            <para><emphasis>ZoomToRectangleMode</emphasis>: you can indicate a
            rectangle (by dragging) and it will zoom to make the selected area
            as big as possible while still entirely inside the map
            widget.</para>
          </listitem>

          <listitem>
            <para><emphasis>ZoomToSelection</emphasis>: First select some
            items on the map. After clicking on the the zoomToSelection button
            the map will be zoomed so that all selected items will fit nicely
            on the screen.</para>
          </listitem>

          <listitem>
            <para><emphasis>panToSelection</emphasis>: irst select some items
            on the map. After clicking on the panToSelection button the map
            will be panned in such a way that the center of the selected items
            is in the center of the screen.</para>
          </listitem>

          <listitem>
            <para><emphasis>ZoomPrevious</emphasis>: go back to the previous
            zoom level (and location).</para>
          </listitem>

          <listitem>
            <para><emphasis>ZoomNext</emphasis>: go forward again, cancelling
            clicking on <emphasis>ZoomPrevious</emphasis>.</para>
          </listitem>
        </itemizedlist></para>

      <figure>
        <title>Toolbar example</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center"
                       fileref="../images/gwtface_widget_toolbar.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>LayerTree</title>

      <para>This widget represents a certain view on the MapModel class, just
      like the MapWidget does, but this time focused on layers. Represented
      here are the map's layers in a tree, just as they are configured.
      Accompanied with this view, there are buttons that define certain
      actions on these layers. Originally there are no buttons in this widget,
      so they have to be added manually or through configuration. These
      buttons can be either single actions, or selectable buttons (similar to
      the Toolbar widget - see <link linkend="interaction">User
      Interaction</link>).</para>

      <para>Lust like the toolbar, the <code>LayerTree</code> waits for the
      <code>MapModel</code> to be initialized, and also reacts on the
      <code>MapModelEvent</code>. If configured so the map configuration also
      contains a layer tree configuration. When the <code>MapModelEvent</code>
      is fired, the <code>LayerTree</code> will try to recover this
      configuration, so it knows how to present itself (what layers in what
      nodes, which buttons to use, ...).</para>

      <para>Below you see a screenshot of a simple <code>LayerTree</code>
      where no layer has been selected (and thus all the buttons are
      disabled):</para>

      <figure>
        <title>LayerTree example</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center"
                       fileref="../images/gwtface_widget_layertree1.png" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Once a layer is selected, the <code>LayerTree</code> will go over
      all buttons and present the selected layer. The buttons then decide
      individually whether or not to change their disabled status to enabled.
      For example, the
      <code>org.geomajas.gwt.client.action.layertree.LabelAction</code>, which
      toggles a layer's labels, is only applicable on vector layers, so if the
      selected layer is a raster layer, that button will still decide to
      remain disabled. To see what the same <code>LayerTree</code> would look
      like if one layer is selected, view here:</para>

      <figure>
        <title>LayerTree with selected layer</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center"
                       fileref="../images/gwtface_widget_layertree2.png" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The <code>LayerTree</code> may have few public methods, but it
      does quie a lot behind the screen. The tree is in fact a SmartGWT
      <code>TreeGrid</code>, where the <code>LayerTree</code> adds handlers to
      the nodes and leafs(a <code>LeafClickHandler</code> and a
      <code>FolderClickHandler</code>), that trigger layer selection within
      the <code>MapModel</code>. At the same time the <code>LayerTree</code>
      listens to layer selection events, to adjust it's own appearance. For
      example, if a layer is selected, the proper noode should be selected as
      well. But more than that, all the buttons need updating as well.</para>

      <para>The <code>LayerTreeAction</code> and
      <code>LayerTreeModalAction</code> are also specifically designed to cope
      with the different stages that they should be able to display. The
      <code>LayerTreeModalAction</code> can be disabled, enabled and selected
      or enabled and deselected. For each it is imperative that clear markings
      are given. This means that different icons are usually used for the
      different stages. These different icons should be given to the actions
      at construction time.</para>

      <para>Currently the following actions are defined:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>org.geomajas.gwt.client.action.layertree.VisibleAction</emphasis>:
          A LayerTreeModalAction that switches the visible flag on the
          selected layer.</para>
        </listitem>

        <listitem>
          <para><emphasis>org.geomajas.gwt.client.action.layertree.LabelAction</emphasis>:
          A LayerTreeModalAction that switches the labeled flag on the
          selected layer.</para>
        </listitem>

        <listitem>
          <para><emphasis>org.geomajas.gwt.client.action.layertree.LayerRefreshAction</emphasis>:
          A LayerTreeAction that refreshes the selected layer on click.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Legend</title>

      <para>The Legend is a graphical widget that shows all currently visible
      styles of all currently visible vector layers. In that sense it is
      another view on the MapModel that only shows the style definitions that
      are currently relevant. Just like the MapWidget, the legend is build
      upon the GraphicsWidget. It reads in the layers available in the
      mapModel and draws a legend to match the style of these layers.</para>

      <figure>
        <title>Legend</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/gwtface_widget_legend.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>FeatureListGrid</title>

      <para>The FeatureListGrid is a table listing of alphanumerical
      attributes of features within a single vector layer. Each feature is
      represented by a row in the grid, with at the top a header that shows
      the attribute label definition, as configured in the XML configuration.
      It speaks for itself that only vector layers can contains features, and
      so this grid can only display the feature attributes of vector
      layers.</para>

      <para>The <code>FeatureListGrid</code> has a few options that determine
      it's behaviour and appearance:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>selectionEnabled</emphasis>: Enables or disables
          selection of features when selecting a row in the table. When this
          is enabled, the table will keep feature selection consistent with
          the <code>MapModel</code>. If the user then selects a row, the
          feature behind it will also be selected, which will trigger the
          MapModel to fire a <code>FeatureSelectedEvent</code> and as a
          result, on the <code>MapWidget</code> it will also become
          selected.</para>
        </listitem>

        <listitem>
          <para><emphasis>allAttributesDisplayed</emphasis>: show all
          attributes (true) or only the 'identifying' attributes (false)?
          Attribute can be configured as "identifying" in their XML
          configuration. This difference allows for a select list of
          attributes to be visible in the grid, keeping overview. Once can
          always ask more details through the
          <code>FeatureAttributeWindow</code> (doubleclicking in the
          grid).</para>
        </listitem>

        <listitem>
          <para><emphasis>editingEnabled</emphasis>: Determines whether or not
          editing the attributes is allowed. When double clicking a row in the
          table, a FeatureAttributeWindow will appear, containing the feature
          of the row upon which was double clicked. This setting determines if
          that window allows editing or not.</para>
        </listitem>

        <listitem>
          <para><emphasis>idInTable</emphasis>: show the feature's id in the
          table. This is false by default, and should not really be
          necessary.</para>
        </listitem>
      </itemizedlist>

      <para>Basically this table is an extension of the SmartGWT
      <code>ListGrid</code> widget. It therefore automatically has grouping,
      filtering and sorting abilities (and much more...). What the
      <code>FeatureListGrid</code> makes possible is to have it display
      features in an easy way. First you have to set the layer from whom to
      display features, and then add features one by one to the grid. If no
      layer is set, then then "<code>addFeature</code>" method will not add
      any rows to the table. Also the setting of the layer will automatically
      create the grid header, using the layer's attribute definitions.</para>

      <figure>
        <title>FeatureListGrid example</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center"
                       fileref="../images/gwtface_widget_featurelistgrid.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>FeatureAttributeWindow</title>

      <para>The <code>FeatureAttributeWindow</code> is a floating window that
      uses a <code>FeatureAttributeEditor</code> to change the alphanumerical
      attributes of a single feature and persist these changes. In essence,
      this widget is a <code>FeatureAttributeEditor</code> with some extra
      buttons. One of these extra buttons is a "save" button to actually save
      the feature. When setting a feature, it first makes a clone that it then
      applies on the underlying <code>FeatureAttributeEditor</code>. That way
      you're not editing the feature directly, and changes are only applied
      when the save is clicked. This widget will also check whether or not all
      fields are valid, and will not allow saving when at least one of the
      fields is not valid.</para>

      <para>The FeatureAttributeWindow has the following options:</para>

      <itemizedlist>
        <listitem>
          <para>editingAllowed: Is editing berhaupt allowed? This must be set
          BEFORE the widget is actually drawn, because afterwards it won't
          have any effect anymore. This</para>
        </listitem>

        <listitem>
          <para>editingEnabled: Is editing currently enabled or not? This
          widget can toggle this value on the fly. When editing is enabled, it
          will display an editable attribute form with save, cancel and reset
          buttons. When editing is not enabled, these buttons will disappear,
          and a simple attribute form is shown that displays the attribute
          values, but does not allow for editing. This effect only has effect
          if editingAllowed has been set to true.</para>
        </listitem>
      </itemizedlist>

      <para>Below is a screenshot of a FeatureAttributeWindow with
      editingAllowed=true and editingEnabled=false. Without the
      editingAllowed, there would be now Edit button, and the edit button
      itself triggers the editingEnabled option to true.</para>

      <figure>
        <title>FeatureAttributeWIndow, editing allowed but not enabled</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center"
                       fileref="../images/gwtface_widget_featureattributewindow.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>ActivityMonitor</title>

      <para>This widget monitors client-server communication traffic, and
      displays that activity to the end-user. It's main purpose is to let the
      user know when to expect some slowdown or when to wait for reaction. For
      example, when the user zooms in on a map, it can sometimes take a few
      seconds before everything is redrawn. This widget displays that traffic
      by listening to the events in the
      <code>org.geomajas.command.CommandResponse.GwtCommandDispatcher</code>.
      On the screenshot below, you can see the difference between it being
      passive and active:</para>

      <figure>
        <title>ActivityMonitor example</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center"
                       fileref="../images/gwtface_widget_activitymonitor.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>ScaleSelect</title>

      <para>Combobox for changing the scale on the map. Can be added to a
      toolbar. It displays a list of possible scales to choose from, but also
      allows for the user to type in a specific scale. The ScaleSelect is
      constructred with a MapView as parameter. If this MapView contains
      pre-configured resolutions (zoom-steps - these can be configured in the
      XML configuration), than the ScaleSelect will display a list of these
      scales. If no pre-configured resolutions are present in the MapView, the
      ScaleSelect will automatically choose relevant scales to choose
      from.</para>

      <para>By using the setScales method, one can always override the list of
      scales in the ScaleSelect to one's own liking.</para>

      <figure>
        <title>ScaleSelect example</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/gwtface_widget_scaleselect.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>FeatureSearch</title>

      <para>Widget that supports searching for features by means of their
      alpha numerical attributes. Requires a value for
      <code>manualLayerSelection</code> at construction time. If true, a
      select box will be shown so the user can select what layer to search in.
      The possible list of layers consists of all the vector layers that are
      present in the given <code>MapModel</code>. If false, this widget will
      react to the layer select events that come from the
      <code>MapModel</code>. In that case searching happens in the selected
      layer (if it's a vector layer).</para>

      <para>By executing a search, this widget will ask the server to actually
      perform the search. When the result returns, a <code>SearchEvent</code>
      is fired. This event will hold the reference to the
      <code>VectorLayer</code> wherein the search took place, and a list of
      all the features that were found. In order to to something with the
      results (such as displaying in a <code>FeatureListGrid</code>), add a
      <code>SearchHandler</code>. For the specific case of displaying the
      feature in a <code>FeatureListGrid</code>, there is a
      <code>DefaultSearchHandler</code> that already does this.</para>

      <para>Note that there is a limit to the amount of features that are
      searched. By default this limit is set to 100. Change the value of
      <code>maximumResultSize</code> to change this. Note that this can have a
      serious impact on performance!</para>

      <figure>
        <title>FeatureSearch example</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center"
                       fileref="../images/gwtface_widget_featuresearch.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Unit testing of GWT widgets</title>

      <para>A GWT unit test should inherit from the <code>GWTTestcase</code>
      base class and should be named <code>GwtTestXxx.java</code>. GWT unit
      tests are run inside a development mode environment and can refer to
      most of the GWT API. To run a GWT test case, run the maven command
      <command>gwt:test </command>or execute the integration test
      phase.</para>
    </section>
  </chapter>
</part>
